diff --git a/.vscode/settings.json b/.vscode/settings.json
index 7797a22..84dd1fc 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -2,6 +2,7 @@
     "files.associations": {
         "precedence_climbing.h": "c",
         "tokenize.h": "c",
-        "test_unit.h": "c"
+        "test_unit.h": "c",
+        "ranges": "c"
     }
 }
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 1a41bb8..ed8da79 100644
--- a/Makefile
+++ b/Makefile
@@ -5,40 +5,39 @@ NAME= minishell
 OS = $(shell uname)
 ifeq ($(OS), Darwin)
 CC=cc
-GFLAGS= -Werror -Wall -Wextra -I./srcs/parser/tokenizer -I./srcs/exec
+GFLAGS= -Werror -Wall -Wextra
 else ifeq ($(OS), Linux)
 CC=gcc
-GFLAGS= -Werror -Wall -Wextra -I./srcs/parser/tokenizer -I./srcs/exec
+GFLAGS= -Werror -Wall -Wextra
 endif
 
-mode=0
-PROD=0
 TEST=1
 PARSER=2
-NOFLAGS=3
 
 MEMORY_CHECK_PATH= error_managment/valgrind
 
 SRCS_MAIN= srcs/main.c
-SRCS_PARSER=  $(wildcard srcs/parser/lexer/**/*.c) $(wildcard srcs/parser/tokenizer/*.c) $(wildcard srcs/parser/*.c)
-SRCS_EXEC= $(wildcard srcs/exec/*.c) #Nami changed
-SRCS_SUB= $(wildcard srcs/subsystems/**/*.c) $(wildcard srcs/subsystems/*.c)
+SRCS_PARSER= $(wildcard srcs/parser/lexer/*.c) $(wildcard srcs/parser/tokenizer/*.c) $(wildcard srcs/parser/*.c)
+SRCS_EXEC_C= $(wildcard srcs/execution/*.c)
+SRCS_EXEC_N= $(wildcard srcs/exec/*.c)
+SRCS_BUILTIN= $(wildcard srcs/builtin/*.c)
 SRCS_TEST= $(wildcard test_unit/*.c)
 
 LIBFT= libft
 
-ifeq ($(mode), $(NOFLAGS))
+ifeq ($(NOFLAGS), 1)
 %.o:%.c
 	$(CC) -c $< -o $@
 else
 %.o:%.c
-	$(CC) $(GFLAGS) -g -c $< -o $@
+	$(CC) $(GFLAGS)  -g -c $< -o $@
 endif
 
 OBJS_MAIN=$(SRCS_MAIN:%.c=%.o)
 OBJS_PARSER=$(SRCS_PARSER:%.c=%.o)
-OBJS_EXEC=$(SRCS_EXEC:%.c=%.o)
-OBJS_SUB=$(SRCS_SUB:%.c=%.o)
+OBJS_EXEC_C=$(SRCS_EXEC_C:%.c=%.o)
+OBJS_EXEC_N=$(SRCS_EXEC_N:%.c=%.o)
+OBJS_BUILTIN=$(SRCS_BUILTIN:%.c=%.o)
 
 # Test env:
 
@@ -50,18 +49,21 @@ gcom=
 EMPTY=
 
 
-ifeq ($(mode), $(PROD))
-OBJS= $(OBJS_MAIN) $(OBJS_PARSER) $(OBJS_EXEC) # Added OBJS_EXEC
-else ifeq ($(mode), $(TEST))
-OBJS= $(OBJS_PARSER) $(OBJS_EXEC) # Added OBJS_EXEC
+ifeq ($(PROD), 1)
+OBJS= $(OBJS_MAIN) $(OBJS_BUILTIN) $(OBJS_PARSER) $(OBJS_EXEC_C) $(OBJS_EXEC_N)
+else ifeq ($(PROD), 0)
+OBJS= $(OBJS_TEST) $(OBJS_PARSER) $(OBJS_BUILTIN) $(OBJS_EXEC_C) $(OBJS_EXEC_N)
 endif
 
 
-.PHONY: clean fclean run git testenv
+
+.PHONY: clean fclean run git testenv var lib t
 
 $(NAME): $(OBJS)
+ifeq ($(NOFLAGS), 0)
+	echo hello
 	$(CC) $(GFLAGS) $(OBJS) -L$(LIBFT) -lft -o $(NAME) -lreadline
-ifeq ($(mode), $(NOFLAGS))
+else ifeq ($(NOFLAGS), 1)
 recall:  $(OBJS)
 	$(CC) $(OBJS) -o $(NAME)
 endif
@@ -87,13 +89,24 @@ mclean:
 	rm -f $(MEMORY_CHECK_PATH)/*
 
 
-t: $(OBJS) $(OBJS_TEST)
+t: $(OBJS) 
+# check if the PROD variable env value. The PROD variable define the path file for compilation especialy for the main().
+ifeq ($(PROD), 0)
+	@echo "\033[44m *** Start $(NAME) in test env \033[0m"
+else
+	@echo "\033[0;32m *** Start $(NAME) in prod env \033[0m"
+endif
+# Check the NOFLAGS variable. If NOFLAGS=1, No flags are used for the compilation and a warning message is displayed.
+ifeq ($(NOFLAGS), 1)
+	@echo "\033[41m *** NO FLAGS! \033[0m\n"
+endif
+# check if the of is darwin/mac
 ifeq ($(OS), Darwin)
-	$(CC) $(GFLAGS) -fsanitize=address  $(OBJS) $(OBJS_TEST) -L$(LIBFT) -lft  -lreadline -o bin/test
-	bin/test.exe
+	@$(CC) $(GFLAGS) -fsanitize=address  $(OBJS) -L $(LIBFT) -lft  -lreadline -o bin/test
+	@bin/test
 else ifeq ($(OS), Linux)
-	$(CC) $(GFLAGS) -g $(OBJS) $(OBJS_TEST) -L$(LIBFT) -lft -lreadline -o bin/test
-	valgrind --leak-check=full --log-file=valg_test  -s ./bin/test
+	@$(CC) $(GFLAGS) -g $(OBJS) -L$(LIBFT) -lft -lreadline -o bin/test
+	@valgrind --leak-check=full --log-file=valg_test  -s ./bin/test
 endif
 
 
@@ -105,9 +118,12 @@ else
 	git add .
 	git commit -m $(NAME)/$(gcom)/$(DATE)
 endif
-	git push origin $(BRANCH)
+	git push  $(BRANCH)
 
 
 all: $(NAME)
 
 re: clean fclean all
+
+lib:
+	cd libft   && make bonus
diff --git a/color_code.txt b/color_code.txt
new file mode 100644
index 0000000..cdb7dc5
--- /dev/null
+++ b/color_code.txt
@@ -0,0 +1,38 @@
+# Styles
+BOLD    = \033[1m
+DIM     = \033[2m
+UNDER   = \033[4m
+BLINK   = \033[5m
+REVERSE = \033[7m
+HIDDEN  = \033[8m
+RESET   = \033[0m
+
+# Couleurs texte
+BLACK   = \033[0;30m
+RED     = \033[0;31m
+GREEN   = \033[0;32m
+YELLOW  = \033[0;33m
+BLUE    = \033[0;34m
+MAGENTA = \033[0;35m
+CYAN    = \033[0;36m
+WHITE   = \033[0;37m
+
+# Couleurs texte en gras (bright)
+BRIGHT_BLACK   = \033[1;30m
+BRIGHT_RED     = \033[1;31m
+BRIGHT_GREEN   = \033[1;32m
+BRIGHT_YELLOW  = \033[1;33m
+BRIGHT_BLUE    = \033[1;34m
+BRIGHT_MAGENTA = \033[1;35m
+BRIGHT_CYAN    = \033[1;36m
+BRIGHT_WHITE   = \033[1;37m
+
+# Couleurs de fond
+BG_BLACK   = \033[40m
+BG_RED     = \033[41m
+BG_GREEN   = \033[42m
+BG_YELLOW  = \033[43m
+BG_BLUE    = \033[44m
+BG_MAGENTA = \033[45m
+BG_CYAN    = \033[46m
+BG_WHITE   = \033[47m
diff --git a/error_managment/valgrind/2025-03-26T12:43:58+01:00 b/error_managment/valgrind/2025-03-26T12:43:58+01:00
new file mode 100644
index 0000000..081ec45
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:43:58+01:00
@@ -0,0 +1,32 @@
+==1239396== Memcheck, a memory error detector
+==1239396== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1239396== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1239396== Command: ./minishell
+==1239396== Parent PID: 1239388
+==1239396== 
+==1239396== 
+==1239396== Process terminating with default action of signal 2 (SIGINT)
+==1239396==    at 0x490875B: kill (syscall-template.S:120)
+==1239396==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239396==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239396==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239396==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239396==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239396==    by 0x109BC2: ft_read_line (parser.c:22)
+==1239396==    by 0x109BF0: ft_start_minishell (parser.c:36)
+==1239396==    by 0x10929F: main (main.c:20)
+==1239396== 
+==1239396== HEAP SUMMARY:
+==1239396==     in use at exit: 210,351 bytes in 247 blocks
+==1239396==   total heap usage: 432 allocs, 185 frees, 224,730 bytes allocated
+==1239396== 
+==1239396== LEAK SUMMARY:
+==1239396==    definitely lost: 0 bytes in 0 blocks
+==1239396==    indirectly lost: 0 bytes in 0 blocks
+==1239396==      possibly lost: 0 bytes in 0 blocks
+==1239396==    still reachable: 210,351 bytes in 247 blocks
+==1239396==         suppressed: 0 bytes in 0 blocks
+==1239396== Reachable blocks (those to which a pointer was found) are not shown.
+==1239396== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1239396== 
+==1239396== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:44:48+01:00 b/error_managment/valgrind/2025-03-26T12:44:48+01:00
new file mode 100644
index 0000000..6e3a85d
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:44:48+01:00
@@ -0,0 +1,32 @@
+==1239651== Memcheck, a memory error detector
+==1239651== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1239651== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1239651== Command: ./minishell
+==1239651== Parent PID: 1239637
+==1239651== 
+==1239651== 
+==1239651== Process terminating with default action of signal 2 (SIGINT)
+==1239651==    at 0x490875B: kill (syscall-template.S:120)
+==1239651==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239651==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239651==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239651==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239651==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239651==    by 0x109BC2: ft_read_line (parser.c:22)
+==1239651==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1239651==    by 0x10929F: main (main.c:20)
+==1239651== 
+==1239651== HEAP SUMMARY:
+==1239651==     in use at exit: 210,635 bytes in 258 blocks
+==1239651==   total heap usage: 677 allocs, 419 frees, 228,201 bytes allocated
+==1239651== 
+==1239651== LEAK SUMMARY:
+==1239651==    definitely lost: 0 bytes in 0 blocks
+==1239651==    indirectly lost: 0 bytes in 0 blocks
+==1239651==      possibly lost: 0 bytes in 0 blocks
+==1239651==    still reachable: 210,635 bytes in 258 blocks
+==1239651==         suppressed: 0 bytes in 0 blocks
+==1239651== Reachable blocks (those to which a pointer was found) are not shown.
+==1239651== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1239651== 
+==1239651== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:45:24+01:00 b/error_managment/valgrind/2025-03-26T12:45:24+01:00
new file mode 100644
index 0000000..938e448
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:45:24+01:00
@@ -0,0 +1,66 @@
+==1239837== Memcheck, a memory error detector
+==1239837== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1239837== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1239837== Command: ./minishell
+==1239837== Parent PID: 1239820
+==1239837== 
+==1239837== Invalid read of size 8
+==1239837==    at 0x1097B2: ft_display_commande_lst (tokenize_utils.c:53)
+==1239837==    by 0x109BF3: ft_read_line (parser.c:26)
+==1239837==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1239837==    by 0x10929F: main (main.c:20)
+==1239837==  Address 0x20 is not stack'd, malloc'd or (recently) free'd
+==1239837== 
+==1239837== 
+==1239837== Process terminating with default action of signal 11 (SIGSEGV)
+==1239837==  Access not within mapped region at address 0x20
+==1239837==    at 0x1097B2: ft_display_commande_lst (tokenize_utils.c:53)
+==1239837==    by 0x109BF3: ft_read_line (parser.c:26)
+==1239837==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1239837==    by 0x10929F: main (main.c:20)
+==1239837==  If you believe this happened as a result of a stack
+==1239837==  overflow in your program's main thread (unlikely but
+==1239837==  possible), you can try to increase the size of the
+==1239837==  main thread stack using the --main-stacksize= flag.
+==1239837==  The main thread stack size used in this run was 8388608.
+==1239837== 
+==1239837== HEAP SUMMARY:
+==1239837==     in use at exit: 210,651 bytes in 260 blocks
+==1239837==   total heap usage: 678 allocs, 418 frees, 228,260 bytes allocated
+==1239837== 
+==1239837== 25 bytes in 1 blocks are definitely lost in loss record 21 of 82
+==1239837==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1239837==    by 0x48ABBAC: xmalloc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239837==    by 0x4889694: readline_internal_teardown (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239837==    by 0x4893D2A: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1239837==    by 0x109BC2: ft_read_line (parser.c:22)
+==1239837==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1239837==    by 0x10929F: main (main.c:20)
+==1239837== 
+==1239837== 272 (8 direct, 264 indirect) bytes in 1 blocks are definitely lost in loss record 39 of 82
+==1239837==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1239837==    by 0x109574: ft_tokenize (tokenize.c:82)
+==1239837==    by 0x109BE0: ft_read_line (parser.c:25)
+==1239837==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1239837==    by 0x10929F: main (main.c:20)
+==1239837== 
+==1239837== LEAK SUMMARY:
+==1239837==    definitely lost: 33 bytes in 2 blocks
+==1239837==    indirectly lost: 264 bytes in 10 blocks
+==1239837==      possibly lost: 0 bytes in 0 blocks
+==1239837==    still reachable: 210,354 bytes in 248 blocks
+==1239837==         suppressed: 0 bytes in 0 blocks
+==1239837== Reachable blocks (those to which a pointer was found) are not shown.
+==1239837== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1239837== 
+==1239837== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
+==1239837== 
+==1239837== 1 errors in context 1 of 3:
+==1239837== Invalid read of size 8
+==1239837==    at 0x1097B2: ft_display_commande_lst (tokenize_utils.c:53)
+==1239837==    by 0x109BF3: ft_read_line (parser.c:26)
+==1239837==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1239837==    by 0x10929F: main (main.c:20)
+==1239837==  Address 0x20 is not stack'd, malloc'd or (recently) free'd
+==1239837== 
+==1239837== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:45:48+01:00 b/error_managment/valgrind/2025-03-26T12:45:48+01:00
new file mode 100644
index 0000000..f5e6325
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:45:48+01:00
@@ -0,0 +1,32 @@
+==1240106== Memcheck, a memory error detector
+==1240106== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1240106== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1240106== Command: ./minishell
+==1240106== Parent PID: 1240098
+==1240106== 
+==1240106== 
+==1240106== Process terminating with default action of signal 2 (SIGINT)
+==1240106==    at 0x490875B: kill (syscall-template.S:120)
+==1240106==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240106==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240106==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240106==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240106==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240106==    by 0x109BC2: ft_read_line (parser.c:22)
+==1240106==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1240106==    by 0x10929F: main (main.c:20)
+==1240106== 
+==1240106== HEAP SUMMARY:
+==1240106==     in use at exit: 210,413 bytes in 250 blocks
+==1240106==   total heap usage: 482 allocs, 232 frees, 225,464 bytes allocated
+==1240106== 
+==1240106== LEAK SUMMARY:
+==1240106==    definitely lost: 0 bytes in 0 blocks
+==1240106==    indirectly lost: 0 bytes in 0 blocks
+==1240106==      possibly lost: 0 bytes in 0 blocks
+==1240106==    still reachable: 210,413 bytes in 250 blocks
+==1240106==         suppressed: 0 bytes in 0 blocks
+==1240106== Reachable blocks (those to which a pointer was found) are not shown.
+==1240106== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1240106== 
+==1240106== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:46:35+01:00 b/error_managment/valgrind/2025-03-26T12:46:35+01:00
new file mode 100644
index 0000000..40cecd4
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:46:35+01:00
@@ -0,0 +1,66 @@
+==1240276== Memcheck, a memory error detector
+==1240276== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1240276== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1240276== Command: ./minishell
+==1240276== Parent PID: 1240268
+==1240276== 
+==1240276== Invalid read of size 8
+==1240276==    at 0x1098AB: ft_display_token_sequence_lst (tokenize_utils.c:89)
+==1240276==    by 0x109BF3: ft_read_line (parser.c:26)
+==1240276==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1240276==    by 0x10929F: main (main.c:20)
+==1240276==  Address 0x20 is not stack'd, malloc'd or (recently) free'd
+==1240276== 
+==1240276== 
+==1240276== Process terminating with default action of signal 11 (SIGSEGV)
+==1240276==  Access not within mapped region at address 0x20
+==1240276==    at 0x1098AB: ft_display_token_sequence_lst (tokenize_utils.c:89)
+==1240276==    by 0x109BF3: ft_read_line (parser.c:26)
+==1240276==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1240276==    by 0x10929F: main (main.c:20)
+==1240276==  If you believe this happened as a result of a stack
+==1240276==  overflow in your program's main thread (unlikely but
+==1240276==  possible), you can try to increase the size of the
+==1240276==  main thread stack using the --main-stacksize= flag.
+==1240276==  The main thread stack size used in this run was 8388608.
+==1240276== 
+==1240276== HEAP SUMMARY:
+==1240276==     in use at exit: 210,423 bytes in 252 blocks
+==1240276==   total heap usage: 486 allocs, 234 frees, 225,514 bytes allocated
+==1240276== 
+==1240276== 6 bytes in 1 blocks are definitely lost in loss record 3 of 82
+==1240276==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1240276==    by 0x48ABBAC: xmalloc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240276==    by 0x4889694: readline_internal_teardown (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240276==    by 0x4893D2A: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240276==    by 0x109BC2: ft_read_line (parser.c:22)
+==1240276==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1240276==    by 0x10929F: main (main.c:20)
+==1240276== 
+==1240276== 62 (8 direct, 54 indirect) bytes in 1 blocks are definitely lost in loss record 28 of 82
+==1240276==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1240276==    by 0x109574: ft_tokenize (tokenize.c:82)
+==1240276==    by 0x109BE0: ft_read_line (parser.c:25)
+==1240276==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1240276==    by 0x10929F: main (main.c:20)
+==1240276== 
+==1240276== LEAK SUMMARY:
+==1240276==    definitely lost: 14 bytes in 2 blocks
+==1240276==    indirectly lost: 54 bytes in 2 blocks
+==1240276==      possibly lost: 0 bytes in 0 blocks
+==1240276==    still reachable: 210,355 bytes in 248 blocks
+==1240276==         suppressed: 0 bytes in 0 blocks
+==1240276== Reachable blocks (those to which a pointer was found) are not shown.
+==1240276== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1240276== 
+==1240276== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
+==1240276== 
+==1240276== 1 errors in context 1 of 3:
+==1240276== Invalid read of size 8
+==1240276==    at 0x1098AB: ft_display_token_sequence_lst (tokenize_utils.c:89)
+==1240276==    by 0x109BF3: ft_read_line (parser.c:26)
+==1240276==    by 0x109C13: ft_start_minishell (parser.c:36)
+==1240276==    by 0x10929F: main (main.c:20)
+==1240276==  Address 0x20 is not stack'd, malloc'd or (recently) free'd
+==1240276== 
+==1240276== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:47:08+01:00 b/error_managment/valgrind/2025-03-26T12:47:08+01:00
new file mode 100644
index 0000000..5c3e9f4
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:47:08+01:00
@@ -0,0 +1,32 @@
+==1240441== Memcheck, a memory error detector
+==1240441== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1240441== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1240441== Command: ./minishell
+==1240441== Parent PID: 1240433
+==1240441== 
+==1240441== 
+==1240441== Process terminating with default action of signal 2 (SIGINT)
+==1240441==    at 0x490875B: kill (syscall-template.S:120)
+==1240441==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240441==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240441==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240441==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240441==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240441==    by 0x109BC2: ft_read_line (parser.c:22)
+==1240441==    by 0x109C2E: ft_start_minishell (parser.c:37)
+==1240441==    by 0x10929F: main (main.c:20)
+==1240441== 
+==1240441== HEAP SUMMARY:
+==1240441==     in use at exit: 210,413 bytes in 250 blocks
+==1240441==   total heap usage: 482 allocs, 232 frees, 225,464 bytes allocated
+==1240441== 
+==1240441== LEAK SUMMARY:
+==1240441==    definitely lost: 0 bytes in 0 blocks
+==1240441==    indirectly lost: 0 bytes in 0 blocks
+==1240441==      possibly lost: 0 bytes in 0 blocks
+==1240441==    still reachable: 210,413 bytes in 250 blocks
+==1240441==         suppressed: 0 bytes in 0 blocks
+==1240441== Reachable blocks (those to which a pointer was found) are not shown.
+==1240441== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1240441== 
+==1240441== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:47:28+01:00 b/error_managment/valgrind/2025-03-26T12:47:28+01:00
new file mode 100644
index 0000000..bd9ac4f
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:47:28+01:00
@@ -0,0 +1,48 @@
+==1240581== Memcheck, a memory error detector
+==1240581== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1240581== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1240581== Command: ./minishell
+==1240581== Parent PID: 1240573
+==1240581== 
+==1240581== 
+==1240581== Process terminating with default action of signal 2 (SIGINT)
+==1240581==    at 0x490875B: kill (syscall-template.S:120)
+==1240581==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x109BC2: ft_read_line (parser.c:22)
+==1240581==    by 0x109C2E: ft_start_minishell (parser.c:37)
+==1240581==    by 0x10929F: main (main.c:20)
+==1240581== 
+==1240581== HEAP SUMMARY:
+==1240581==     in use at exit: 210,825 bytes in 268 blocks
+==1240581==   total heap usage: 811 allocs, 543 frees, 230,312 bytes allocated
+==1240581== 
+==1240581== 26 bytes in 2 blocks are definitely lost in loss record 22 of 84
+==1240581==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1240581==    by 0x48ABBAC: xmalloc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x4889694: readline_internal_teardown (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x4893D2A: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240581==    by 0x109BC2: ft_read_line (parser.c:22)
+==1240581==    by 0x109C2E: ft_start_minishell (parser.c:37)
+==1240581==    by 0x10929F: main (main.c:20)
+==1240581== 
+==1240581== 330 (16 direct, 314 indirect) bytes in 2 blocks are definitely lost in loss record 41 of 84
+==1240581==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1240581==    by 0x109574: ft_tokenize (tokenize.c:82)
+==1240581==    by 0x109BFB: ft_read_line (parser.c:26)
+==1240581==    by 0x109C2E: ft_start_minishell (parser.c:37)
+==1240581==    by 0x10929F: main (main.c:20)
+==1240581== 
+==1240581== LEAK SUMMARY:
+==1240581==    definitely lost: 42 bytes in 4 blocks
+==1240581==    indirectly lost: 314 bytes in 12 blocks
+==1240581==      possibly lost: 0 bytes in 0 blocks
+==1240581==    still reachable: 210,469 bytes in 252 blocks
+==1240581==         suppressed: 0 bytes in 0 blocks
+==1240581== Reachable blocks (those to which a pointer was found) are not shown.
+==1240581== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1240581== 
+==1240581== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:48:28+01:00 b/error_managment/valgrind/2025-03-26T12:48:28+01:00
new file mode 100644
index 0000000..aa63efc
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:48:28+01:00
@@ -0,0 +1,32 @@
+==1240907== Memcheck, a memory error detector
+==1240907== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1240907== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1240907== Command: ./minishell
+==1240907== Parent PID: 1240899
+==1240907== 
+==1240907== 
+==1240907== Process terminating with default action of signal 2 (SIGINT)
+==1240907==    at 0x490875B: kill (syscall-template.S:120)
+==1240907==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240907==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240907==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240907==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240907==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1240907==    by 0x109BBC: ft_read_line (parser.c:22)
+==1240907==    by 0x109C28: ft_start_minishell (parser.c:37)
+==1240907==    by 0x10929F: main (main.c:20)
+==1240907== 
+==1240907== HEAP SUMMARY:
+==1240907==     in use at exit: 210,469 bytes in 252 blocks
+==1240907==   total heap usage: 515 allocs, 263 frees, 225,995 bytes allocated
+==1240907== 
+==1240907== LEAK SUMMARY:
+==1240907==    definitely lost: 0 bytes in 0 blocks
+==1240907==    indirectly lost: 0 bytes in 0 blocks
+==1240907==      possibly lost: 0 bytes in 0 blocks
+==1240907==    still reachable: 210,469 bytes in 252 blocks
+==1240907==         suppressed: 0 bytes in 0 blocks
+==1240907== Reachable blocks (those to which a pointer was found) are not shown.
+==1240907== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1240907== 
+==1240907== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:48:39+01:00 b/error_managment/valgrind/2025-03-26T12:48:39+01:00
new file mode 100644
index 0000000..9782900
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:48:39+01:00
@@ -0,0 +1,32 @@
+==1241013== Memcheck, a memory error detector
+==1241013== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1241013== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1241013== Command: ./minishell
+==1241013== Parent PID: 1241005
+==1241013== 
+==1241013== 
+==1241013== Process terminating with default action of signal 2 (SIGINT)
+==1241013==    at 0x490875B: kill (syscall-template.S:120)
+==1241013==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241013==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241013==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241013==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241013==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241013==    by 0x109BB3: ft_read_line (parser.c:22)
+==1241013==    by 0x109C1F: ft_start_minishell (parser.c:37)
+==1241013==    by 0x10929F: main (main.c:20)
+==1241013== 
+==1241013== HEAP SUMMARY:
+==1241013==     in use at exit: 210,582 bytes in 256 blocks
+==1241013==   total heap usage: 614 allocs, 358 frees, 227,400 bytes allocated
+==1241013== 
+==1241013== LEAK SUMMARY:
+==1241013==    definitely lost: 0 bytes in 0 blocks
+==1241013==    indirectly lost: 0 bytes in 0 blocks
+==1241013==      possibly lost: 0 bytes in 0 blocks
+==1241013==    still reachable: 210,582 bytes in 256 blocks
+==1241013==         suppressed: 0 bytes in 0 blocks
+==1241013== Reachable blocks (those to which a pointer was found) are not shown.
+==1241013== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1241013== 
+==1241013== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:48:53+01:00 b/error_managment/valgrind/2025-03-26T12:48:53+01:00
new file mode 100644
index 0000000..38d049f
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:48:53+01:00
@@ -0,0 +1,48 @@
+==1241081== Memcheck, a memory error detector
+==1241081== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1241081== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1241081== Command: ./minishell
+==1241081== Parent PID: 1241073
+==1241081== 
+==1241081== 
+==1241081== Process terminating with default action of signal 2 (SIGINT)
+==1241081==    at 0x490875B: kill (syscall-template.S:120)
+==1241081==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x109BB3: ft_read_line (parser.c:22)
+==1241081==    by 0x109C1F: ft_start_minishell (parser.c:37)
+==1241081==    by 0x10929F: main (main.c:20)
+==1241081== 
+==1241081== HEAP SUMMARY:
+==1241081==     in use at exit: 210,828 bytes in 268 blocks
+==1241081==   total heap usage: 773 allocs, 505 frees, 229,876 bytes allocated
+==1241081== 
+==1241081== 35 bytes in 2 blocks are definitely lost in loss record 24 of 84
+==1241081==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1241081==    by 0x48ABBAC: xmalloc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x4889694: readline_internal_teardown (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x4893D2A: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241081==    by 0x109BB3: ft_read_line (parser.c:22)
+==1241081==    by 0x109C1F: ft_start_minishell (parser.c:37)
+==1241081==    by 0x10929F: main (main.c:20)
+==1241081== 
+==1241081== 386 (16 direct, 370 indirect) bytes in 2 blocks are definitely lost in loss record 41 of 84
+==1241081==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1241081==    by 0x109574: ft_tokenize (tokenize.c:82)
+==1241081==    by 0x109BEC: ft_read_line (parser.c:26)
+==1241081==    by 0x109C1F: ft_start_minishell (parser.c:37)
+==1241081==    by 0x10929F: main (main.c:20)
+==1241081== 
+==1241081== LEAK SUMMARY:
+==1241081==    definitely lost: 51 bytes in 4 blocks
+==1241081==    indirectly lost: 370 bytes in 14 blocks
+==1241081==      possibly lost: 0 bytes in 0 blocks
+==1241081==    still reachable: 210,407 bytes in 250 blocks
+==1241081==         suppressed: 0 bytes in 0 blocks
+==1241081== Reachable blocks (those to which a pointer was found) are not shown.
+==1241081== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1241081== 
+==1241081== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:50:46+01:00 b/error_managment/valgrind/2025-03-26T12:50:46+01:00
new file mode 100644
index 0000000..8f92bde
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:50:46+01:00
@@ -0,0 +1,32 @@
+==1241507== Memcheck, a memory error detector
+==1241507== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1241507== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1241507== Command: ./minishell
+==1241507== Parent PID: 1241493
+==1241507== 
+==1241507== 
+==1241507== Process terminating with default action of signal 2 (SIGINT)
+==1241507==    at 0x490875B: kill (syscall-template.S:120)
+==1241507==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241507==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241507==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241507==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241507==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241507==    by 0x109BB3: ft_read_line (parser.c:22)
+==1241507==    by 0x109C04: ft_start_minishell (parser.c:35)
+==1241507==    by 0x10929F: main (main.c:20)
+==1241507== 
+==1241507== HEAP SUMMARY:
+==1241507==     in use at exit: 210,642 bytes in 258 blocks
+==1241507==   total heap usage: 666 allocs, 408 frees, 228,232 bytes allocated
+==1241507== 
+==1241507== LEAK SUMMARY:
+==1241507==    definitely lost: 0 bytes in 0 blocks
+==1241507==    indirectly lost: 0 bytes in 0 blocks
+==1241507==      possibly lost: 0 bytes in 0 blocks
+==1241507==    still reachable: 210,642 bytes in 258 blocks
+==1241507==         suppressed: 0 bytes in 0 blocks
+==1241507== Reachable blocks (those to which a pointer was found) are not shown.
+==1241507== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1241507== 
+==1241507== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:51:07+01:00 b/error_managment/valgrind/2025-03-26T12:51:07+01:00
new file mode 100644
index 0000000..485b026
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:51:07+01:00
@@ -0,0 +1,48 @@
+==1241636== Memcheck, a memory error detector
+==1241636== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1241636== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1241636== Command: ./minishell
+==1241636== Parent PID: 1241622
+==1241636== 
+==1241636== 
+==1241636== Process terminating with default action of signal 2 (SIGINT)
+==1241636==    at 0x490875B: kill (syscall-template.S:120)
+==1241636==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x109BB3: ft_read_line (parser.c:22)
+==1241636==    by 0x109C04: ft_start_minishell (parser.c:35)
+==1241636==    by 0x10929F: main (main.c:20)
+==1241636== 
+==1241636== HEAP SUMMARY:
+==1241636==     in use at exit: 210,541 bytes in 256 blocks
+==1241636==   total heap usage: 585 allocs, 329 frees, 226,996 bytes allocated
+==1241636== 
+==1241636== 6 bytes in 1 blocks are definitely lost in loss record 2 of 84
+==1241636==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1241636==    by 0x48ABBAC: xmalloc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x4889694: readline_internal_teardown (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x4893D2A: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241636==    by 0x109BB3: ft_read_line (parser.c:22)
+==1241636==    by 0x109C04: ft_start_minishell (parser.c:35)
+==1241636==    by 0x10929F: main (main.c:20)
+==1241636== 
+==1241636== 62 (8 direct, 54 indirect) bytes in 1 blocks are definitely lost in loss record 29 of 84
+==1241636==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==1241636==    by 0x109574: ft_tokenize (tokenize.c:82)
+==1241636==    by 0x109BD1: ft_read_line (parser.c:25)
+==1241636==    by 0x109C04: ft_start_minishell (parser.c:35)
+==1241636==    by 0x10929F: main (main.c:20)
+==1241636== 
+==1241636== LEAK SUMMARY:
+==1241636==    definitely lost: 14 bytes in 2 blocks
+==1241636==    indirectly lost: 54 bytes in 2 blocks
+==1241636==      possibly lost: 0 bytes in 0 blocks
+==1241636==    still reachable: 210,473 bytes in 252 blocks
+==1241636==         suppressed: 0 bytes in 0 blocks
+==1241636== Reachable blocks (those to which a pointer was found) are not shown.
+==1241636== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1241636== 
+==1241636== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-26T12:51:35+01:00 b/error_managment/valgrind/2025-03-26T12:51:35+01:00
new file mode 100644
index 0000000..fa398d7
--- /dev/null
+++ b/error_managment/valgrind/2025-03-26T12:51:35+01:00
@@ -0,0 +1,32 @@
+==1241799== Memcheck, a memory error detector
+==1241799== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1241799== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1241799== Command: ./minishell
+==1241799== Parent PID: 1241785
+==1241799== 
+==1241799== 
+==1241799== Process terminating with default action of signal 2 (SIGINT)
+==1241799==    at 0x490875B: kill (syscall-template.S:120)
+==1241799==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241799==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241799==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241799==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241799==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==1241799==    by 0x109BAD: ft_read_line (parser.c:22)
+==1241799==    by 0x109BFE: ft_start_minishell (parser.c:35)
+==1241799==    by 0x10929F: main (main.c:20)
+==1241799== 
+==1241799== HEAP SUMMARY:
+==1241799==     in use at exit: 210,473 bytes in 252 blocks
+==1241799==   total heap usage: 530 allocs, 278 frees, 226,188 bytes allocated
+==1241799== 
+==1241799== LEAK SUMMARY:
+==1241799==    definitely lost: 0 bytes in 0 blocks
+==1241799==    indirectly lost: 0 bytes in 0 blocks
+==1241799==      possibly lost: 0 bytes in 0 blocks
+==1241799==    still reachable: 210,473 bytes in 252 blocks
+==1241799==         suppressed: 0 bytes in 0 blocks
+==1241799== Reachable blocks (those to which a pointer was found) are not shown.
+==1241799== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1241799== 
+==1241799== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-28T14:02:50+01:00 b/error_managment/valgrind/2025-03-28T14:02:50+01:00
new file mode 100644
index 0000000..de103c1
--- /dev/null
+++ b/error_managment/valgrind/2025-03-28T14:02:50+01:00
@@ -0,0 +1,37 @@
+==979380== Memcheck, a memory error detector
+==979380== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==979380== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==979380== Command: ./minishell
+==979380== Parent PID: 979366
+==979380== 
+==979380== 
+==979380== HEAP SUMMARY:
+==979380==     in use at exit: 204,237 bytes in 225 blocks
+==979380==   total heap usage: 485 allocs, 260 frees, 225,594 bytes allocated
+==979380== 
+==979380== 6 bytes in 1 blocks are definitely lost in loss record 2 of 66
+==979380==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==979380==    by 0x48ABBAC: xmalloc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==979380==    by 0x4889694: readline_internal_teardown (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==979380==    by 0x4893D2A: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==979380==    by 0x109EAD: ft_read_line (parser.c:22)
+==979380==    by 0x109EFE: ft_start_minishell (parser.c:35)
+==979380==    by 0x10939F: main (main.c:20)
+==979380== 
+==979380== 62 (8 direct, 54 indirect) bytes in 1 blocks are definitely lost in loss record 19 of 66
+==979380==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==979380==    by 0x10987A: ft_tokenize (tokenize.c:82)
+==979380==    by 0x109ECB: ft_read_line (parser.c:25)
+==979380==    by 0x109EFE: ft_start_minishell (parser.c:35)
+==979380==    by 0x10939F: main (main.c:20)
+==979380== 
+==979380== LEAK SUMMARY:
+==979380==    definitely lost: 14 bytes in 2 blocks
+==979380==    indirectly lost: 54 bytes in 2 blocks
+==979380==      possibly lost: 0 bytes in 0 blocks
+==979380==    still reachable: 204,169 bytes in 221 blocks
+==979380==         suppressed: 0 bytes in 0 blocks
+==979380== Reachable blocks (those to which a pointer was found) are not shown.
+==979380== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==979380== 
+==979380== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-03-28T14:08:39+01:00 b/error_managment/valgrind/2025-03-28T14:08:39+01:00
new file mode 100644
index 0000000..793b5c0
--- /dev/null
+++ b/error_managment/valgrind/2025-03-28T14:08:39+01:00
@@ -0,0 +1,21 @@
+==982471== Memcheck, a memory error detector
+==982471== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==982471== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==982471== Command: ./minishell
+==982471== Parent PID: 982460
+==982471== 
+==982471== 
+==982471== HEAP SUMMARY:
+==982471==     in use at exit: 204,169 bytes in 221 blocks
+==982471==   total heap usage: 427 allocs, 206 frees, 224,720 bytes allocated
+==982471== 
+==982471== LEAK SUMMARY:
+==982471==    definitely lost: 0 bytes in 0 blocks
+==982471==    indirectly lost: 0 bytes in 0 blocks
+==982471==      possibly lost: 0 bytes in 0 blocks
+==982471==    still reachable: 204,169 bytes in 221 blocks
+==982471==         suppressed: 0 bytes in 0 blocks
+==982471== Reachable blocks (those to which a pointer was found) are not shown.
+==982471== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==982471== 
+==982471== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:32:31+02:00 b/error_managment/valgrind/2025-04-04T15:32:31+02:00
new file mode 100644
index 0000000..a9c069c
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:32:31+02:00
@@ -0,0 +1,32 @@
+==2312398== Memcheck, a memory error detector
+==2312398== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2312398== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2312398== Command: ./minishell
+==2312398== Parent PID: 2312333
+==2312398== 
+==2312398== 
+==2312398== Process terminating with default action of signal 2 (SIGINT)
+==2312398==    at 0x490875B: kill (syscall-template.S:120)
+==2312398==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2312398==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2312398==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2312398==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2312398==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2312398==    by 0x10A771: ft_read_line (parser.c:43)
+==2312398==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2312398==    by 0x1094BF: main (main.c:18)
+==2312398== 
+==2312398== HEAP SUMMARY:
+==2312398==     in use at exit: 214,517 bytes in 252 blocks
+==2312398==   total heap usage: 489 allocs, 237 frees, 229,712 bytes allocated
+==2312398== 
+==2312398== LEAK SUMMARY:
+==2312398==    definitely lost: 0 bytes in 0 blocks
+==2312398==    indirectly lost: 0 bytes in 0 blocks
+==2312398==      possibly lost: 0 bytes in 0 blocks
+==2312398==    still reachable: 214,517 bytes in 252 blocks
+==2312398==         suppressed: 0 bytes in 0 blocks
+==2312398== Reachable blocks (those to which a pointer was found) are not shown.
+==2312398== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2312398== 
+==2312398== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:34:30+02:00 b/error_managment/valgrind/2025-04-04T15:34:30+02:00
new file mode 100644
index 0000000..b35ab36
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:34:30+02:00
@@ -0,0 +1,21 @@
+==1591167== Memcheck, a memory error detector
+==1591167== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1591167== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1591167== Command: ./minishell
+==1591167== Parent PID: 1590664
+==1591167== 
+==1591167== 
+==1591167== HEAP SUMMARY:
+==1591167==     in use at exit: 204,156 bytes in 221 blocks
+==1591167==   total heap usage: 427 allocs, 206 frees, 224,701 bytes allocated
+==1591167== 
+==1591167== LEAK SUMMARY:
+==1591167==    definitely lost: 0 bytes in 0 blocks
+==1591167==    indirectly lost: 0 bytes in 0 blocks
+==1591167==      possibly lost: 0 bytes in 0 blocks
+==1591167==    still reachable: 204,156 bytes in 221 blocks
+==1591167==         suppressed: 0 bytes in 0 blocks
+==1591167== Reachable blocks (those to which a pointer was found) are not shown.
+==1591167== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==1591167== 
+==1591167== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:39:39+02:00 b/error_managment/valgrind/2025-04-04T15:39:39+02:00
new file mode 100644
index 0000000..42429bf
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:39:39+02:00
@@ -0,0 +1,32 @@
+==2313693== Memcheck, a memory error detector
+==2313693== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2313693== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2313693== Command: ./minishell
+==2313693== Parent PID: 2313684
+==2313693== 
+==2313693== 
+==2313693== Process terminating with default action of signal 2 (SIGINT)
+==2313693==    at 0x490875B: kill (syscall-template.S:120)
+==2313693==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313693==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313693==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313693==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313693==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313693==    by 0x10A771: ft_read_line (parser.c:43)
+==2313693==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2313693==    by 0x1094BF: main (main.c:18)
+==2313693== 
+==2313693== HEAP SUMMARY:
+==2313693==     in use at exit: 210,405 bytes in 246 blocks
+==2313693==   total heap usage: 427 allocs, 181 frees, 224,780 bytes allocated
+==2313693== 
+==2313693== LEAK SUMMARY:
+==2313693==    definitely lost: 0 bytes in 0 blocks
+==2313693==    indirectly lost: 0 bytes in 0 blocks
+==2313693==      possibly lost: 0 bytes in 0 blocks
+==2313693==    still reachable: 210,405 bytes in 246 blocks
+==2313693==         suppressed: 0 bytes in 0 blocks
+==2313693== Reachable blocks (those to which a pointer was found) are not shown.
+==2313693== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2313693== 
+==2313693== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:39:55+02:00 b/error_managment/valgrind/2025-04-04T15:39:55+02:00
new file mode 100644
index 0000000..3d641da
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:39:55+02:00
@@ -0,0 +1,32 @@
+==2313807== Memcheck, a memory error detector
+==2313807== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2313807== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2313807== Command: ./minishell
+==2313807== Parent PID: 2313798
+==2313807== 
+==2313807== 
+==2313807== Process terminating with default action of signal 2 (SIGINT)
+==2313807==    at 0x490875B: kill (syscall-template.S:120)
+==2313807==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313807==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313807==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313807==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313807==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313807==    by 0x10A771: ft_read_line (parser.c:43)
+==2313807==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2313807==    by 0x1094BF: main (main.c:18)
+==2313807== 
+==2313807== HEAP SUMMARY:
+==2313807==     in use at exit: 210,405 bytes in 246 blocks
+==2313807==   total heap usage: 427 allocs, 181 frees, 224,780 bytes allocated
+==2313807== 
+==2313807== LEAK SUMMARY:
+==2313807==    definitely lost: 0 bytes in 0 blocks
+==2313807==    indirectly lost: 0 bytes in 0 blocks
+==2313807==      possibly lost: 0 bytes in 0 blocks
+==2313807==    still reachable: 210,405 bytes in 246 blocks
+==2313807==         suppressed: 0 bytes in 0 blocks
+==2313807== Reachable blocks (those to which a pointer was found) are not shown.
+==2313807== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2313807== 
+==2313807== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:40:09+02:00 b/error_managment/valgrind/2025-04-04T15:40:09+02:00
new file mode 100644
index 0000000..1453157
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:40:09+02:00
@@ -0,0 +1,32 @@
+==2313928== Memcheck, a memory error detector
+==2313928== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2313928== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2313928== Command: ./minishell
+==2313928== Parent PID: 2313919
+==2313928== 
+==2313928== 
+==2313928== Process terminating with default action of signal 2 (SIGINT)
+==2313928==    at 0x490875B: kill (syscall-template.S:120)
+==2313928==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313928==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313928==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313928==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313928==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2313928==    by 0x10A771: ft_read_line (parser.c:43)
+==2313928==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2313928==    by 0x1094BF: main (main.c:18)
+==2313928== 
+==2313928== HEAP SUMMARY:
+==2313928==     in use at exit: 210,405 bytes in 246 blocks
+==2313928==   total heap usage: 427 allocs, 181 frees, 224,780 bytes allocated
+==2313928== 
+==2313928== LEAK SUMMARY:
+==2313928==    definitely lost: 0 bytes in 0 blocks
+==2313928==    indirectly lost: 0 bytes in 0 blocks
+==2313928==      possibly lost: 0 bytes in 0 blocks
+==2313928==    still reachable: 210,405 bytes in 246 blocks
+==2313928==         suppressed: 0 bytes in 0 blocks
+==2313928== Reachable blocks (those to which a pointer was found) are not shown.
+==2313928== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2313928== 
+==2313928== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:45:49+02:00 b/error_managment/valgrind/2025-04-04T15:45:49+02:00
new file mode 100644
index 0000000..7355209
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:45:49+02:00
@@ -0,0 +1,126 @@
+==2314704== Memcheck, a memory error detector
+==2314704== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2314704== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2314704== Command: ./minishell
+==2314704== Parent PID: 2314695
+==2314704== 
+==2314714== 
+==2314714== HEAP SUMMARY:
+==2314714==     in use at exit: 208,397 bytes in 232 blocks
+==2314714==   total heap usage: 575 allocs, 343 frees, 230,985 bytes allocated
+==2314714== 
+==2314714== LEAK SUMMARY:
+==2314714==    definitely lost: 0 bytes in 0 blocks
+==2314714==    indirectly lost: 0 bytes in 0 blocks
+==2314714==      possibly lost: 0 bytes in 0 blocks
+==2314714==    still reachable: 208,397 bytes in 232 blocks
+==2314714==         suppressed: 0 bytes in 0 blocks
+==2314714== Reachable blocks (those to which a pointer was found) are not shown.
+==2314714== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2314714== 
+==2314714== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==2314715== 
+==2314715== HEAP SUMMARY:
+==2314715==     in use at exit: 208,397 bytes in 232 blocks
+==2314715==   total heap usage: 575 allocs, 343 frees, 230,985 bytes allocated
+==2314715== 
+==2314715== LEAK SUMMARY:
+==2314715==    definitely lost: 0 bytes in 0 blocks
+==2314715==    indirectly lost: 0 bytes in 0 blocks
+==2314715==      possibly lost: 0 bytes in 0 blocks
+==2314715==    still reachable: 208,397 bytes in 232 blocks
+==2314715==         suppressed: 0 bytes in 0 blocks
+==2314715== Reachable blocks (those to which a pointer was found) are not shown.
+==2314715== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2314715== 
+==2314715== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==2314748== 
+==2314748== HEAP SUMMARY:
+==2314748==     in use at exit: 208,732 bytes in 247 blocks
+==2314748==   total heap usage: 861 allocs, 614 frees, 235,314 bytes allocated
+==2314748== 
+==2314748== 156 (48 direct, 108 indirect) bytes in 1 blocks are definitely lost in loss record 33 of 77
+==2314748==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2314748==    by 0x109CA8: ft_new_token_node (tokenize.c:94)
+==2314748==    by 0x10A056: ft_tokenize (tokenize.c:174)
+==2314748==    by 0x10A1CC: ft_parse (tokenize.c:295)
+==2314748==    by 0x10A7CD: ft_read_line (parser.c:50)
+==2314748==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2314748==    by 0x1094BF: main (main.c:18)
+==2314748== 
+==2314748== LEAK SUMMARY:
+==2314748==    definitely lost: 48 bytes in 1 blocks
+==2314748==    indirectly lost: 108 bytes in 5 blocks
+==2314748==      possibly lost: 0 bytes in 0 blocks
+==2314748==    still reachable: 208,576 bytes in 241 blocks
+==2314748==         suppressed: 0 bytes in 0 blocks
+==2314748== Reachable blocks (those to which a pointer was found) are not shown.
+==2314748== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2314748== 
+==2314748== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
+==2314704== 
+==2314704== Process terminating with default action of signal 2 (SIGINT)
+==2314747== 
+==2314747== Process terminating with default action of signal 2 (SIGINT)
+==2314704==    at 0x49B03EA: wait4 (wait4.c:30)
+==2314747==    at 0x49B03EA: wait4 (wait4.c:30)
+==2314704==    by 0x10AC8B: execute_pipe (exec.c:132)
+==2314704==    by 0x10AEF1: execute_ast (exec.c:209)
+==2314747==    by 0x10A911: execute_command (exec.c:18)
+==2314704==    by 0x10A821: ft_read_line (parser.c:61)
+==2314747==    by 0x10AEE0: execute_ast (exec.c:205)
+==2314704==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2314747==    by 0x10AC0E: execute_pipe (exec.c:114)
+==2314704==    by 0x1094BF: main (main.c:18)
+==2314747==    by 0x10AEF1: execute_ast (exec.c:209)
+==2314747==    by 0x10A821: ft_read_line (parser.c:61)
+==2314747==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2314747==    by 0x1094BF: main (main.c:18)
+==2314704== 
+==2314747== 
+==2314704== HEAP SUMMARY:
+==2314704==     in use at exit: 214,972 bytes in 272 blocks
+==2314704==   total heap usage: 861 allocs, 589 frees, 235,314 bytes allocated
+==2314704== 
+==2314747== HEAP SUMMARY:
+==2314747==     in use at exit: 214,972 bytes in 272 blocks
+==2314747==   total heap usage: 861 allocs, 589 frees, 235,314 bytes allocated
+==2314747== 
+==2314704== 156 (48 direct, 108 indirect) bytes in 1 blocks are definitely lost in loss record 41 of 91
+==2314747== 156 (48 direct, 108 indirect) bytes in 1 blocks are definitely lost in loss record 41 of 91
+==2314704==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2314747==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2314704==    by 0x109CA8: ft_new_token_node (tokenize.c:94)
+==2314747==    by 0x109CA8: ft_new_token_node (tokenize.c:94)
+==2314704==    by 0x10A056: ft_tokenize (tokenize.c:174)
+==2314747==    by 0x10A056: ft_tokenize (tokenize.c:174)
+==2314704==    by 0x10A1CC: ft_parse (tokenize.c:295)
+==2314747==    by 0x10A1CC: ft_parse (tokenize.c:295)
+==2314704==    by 0x10A7CD: ft_read_line (parser.c:50)
+==2314747==    by 0x10A7CD: ft_read_line (parser.c:50)
+==2314704==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2314747==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2314704==    by 0x1094BF: main (main.c:18)
+==2314747==    by 0x1094BF: main (main.c:18)
+==2314704== 
+==2314747== 
+==2314747== LEAK SUMMARY:
+==2314747==    definitely lost: 48 bytes in 1 blocks
+==2314747==    indirectly lost: 108 bytes in 5 blocks
+==2314747==      possibly lost: 0 bytes in 0 blocks
+==2314747==    still reachable: 214,816 bytes in 266 blocks
+==2314704== LEAK SUMMARY:
+==2314747==         suppressed: 0 bytes in 0 blocks
+==2314704==    definitely lost: 48 bytes in 1 blocks
+==2314747== Reachable blocks (those to which a pointer was found) are not shown.
+==2314704==    indirectly lost: 108 bytes in 5 blocks
+==2314747== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2314704==      possibly lost: 0 bytes in 0 blocks
+==2314747== 
+==2314704==    still reachable: 214,816 bytes in 266 blocks
+==2314747== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
+==2314704==         suppressed: 0 bytes in 0 blocks
+==2314704== Reachable blocks (those to which a pointer was found) are not shown.
+==2314704== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2314704== 
+==2314704== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:46:34+02:00 b/error_managment/valgrind/2025-04-04T15:46:34+02:00
new file mode 100644
index 0000000..05999e9
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:46:34+02:00
@@ -0,0 +1,69 @@
+==2314954== Memcheck, a memory error detector
+==2314954== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2314954== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2314954== Command: ./minishell
+==2314954== Parent PID: 2314945
+==2314954== 
+==2315006== 
+==2315006== HEAP SUMMARY:
+==2315006==     in use at exit: 208,525 bytes in 236 blocks
+==2315006==   total heap usage: 667 allocs, 431 frees, 232,460 bytes allocated
+==2315006== 
+==2315006== LEAK SUMMARY:
+==2315006==    definitely lost: 0 bytes in 0 blocks
+==2315006==    indirectly lost: 0 bytes in 0 blocks
+==2315006==      possibly lost: 0 bytes in 0 blocks
+==2315006==    still reachable: 208,525 bytes in 236 blocks
+==2315006==         suppressed: 0 bytes in 0 blocks
+==2315006== Reachable blocks (those to which a pointer was found) are not shown.
+==2315006== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2315006== 
+==2315006== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==2314954== 
+==2314954== Process terminating with default action of signal 2 (SIGINT)
+==2315005== 
+==2315005== Process terminating with default action of signal 2 (SIGINT)
+==2314954==    at 0x49B03EA: wait4 (wait4.c:30)
+==2315005==    at 0x49B03EA: wait4 (wait4.c:30)
+==2314954==    by 0x10AC8B: execute_pipe (exec.c:132)
+==2315005==    by 0x10A911: execute_command (exec.c:18)
+==2314954==    by 0x10AEF1: execute_ast (exec.c:209)
+==2315005==    by 0x10AEE0: execute_ast (exec.c:205)
+==2314954==    by 0x10A821: ft_read_line (parser.c:61)
+==2315005==    by 0x10AC0E: execute_pipe (exec.c:114)
+==2314954==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2315005==    by 0x10AEF1: execute_ast (exec.c:209)
+==2314954==    by 0x1094BF: main (main.c:18)
+==2315005==    by 0x10A821: ft_read_line (parser.c:61)
+==2315005==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2315005==    by 0x1094BF: main (main.c:18)
+==2314954== 
+==2315005== 
+==2314954== HEAP SUMMARY:
+==2314954==     in use at exit: 214,765 bytes in 261 blocks
+==2314954==   total heap usage: 667 allocs, 406 frees, 232,460 bytes allocated
+==2314954== 
+==2315005== HEAP SUMMARY:
+==2315005==     in use at exit: 214,765 bytes in 261 blocks
+==2315005==   total heap usage: 667 allocs, 406 frees, 232,460 bytes allocated
+==2315005== 
+==2314954== LEAK SUMMARY:
+==2315005== LEAK SUMMARY:
+==2314954==    definitely lost: 0 bytes in 0 blocks
+==2315005==    definitely lost: 0 bytes in 0 blocks
+==2314954==    indirectly lost: 0 bytes in 0 blocks
+==2315005==    indirectly lost: 0 bytes in 0 blocks
+==2314954==      possibly lost: 0 bytes in 0 blocks
+==2315005==      possibly lost: 0 bytes in 0 blocks
+==2314954==    still reachable: 214,765 bytes in 261 blocks
+==2315005==    still reachable: 214,765 bytes in 261 blocks
+==2314954==         suppressed: 0 bytes in 0 blocks
+==2315005==         suppressed: 0 bytes in 0 blocks
+==2314954== Reachable blocks (those to which a pointer was found) are not shown.
+==2315005== Reachable blocks (those to which a pointer was found) are not shown.
+==2314954== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2315005== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2314954== 
+==2315005== 
+==2314954== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==2315005== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:55:50+02:00 b/error_managment/valgrind/2025-04-04T15:55:50+02:00
new file mode 100644
index 0000000..e8972c6
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:55:50+02:00
@@ -0,0 +1,41 @@
+==2317516== Memcheck, a memory error detector
+==2317516== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2317516== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2317516== Command: ./minishell
+==2317516== Parent PID: 2317507
+==2317516== 
+==2317516== 
+==2317516== Process terminating with default action of signal 2 (SIGINT)
+==2317516==    at 0x490875B: kill (syscall-template.S:120)
+==2317516==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317516==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317516==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317516==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317516==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317516==    by 0x10A771: ft_read_line (parser.c:43)
+==2317516==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2317516==    by 0x1094BF: main (main.c:18)
+==2317516== 
+==2317516== HEAP SUMMARY:
+==2317516==     in use at exit: 214,979 bytes in 276 blocks
+==2317516==   total heap usage: 764 allocs, 488 frees, 233,794 bytes allocated
+==2317516== 
+==2317516== 255 (192 direct, 63 indirect) bytes in 4 blocks are definitely lost in loss record 40 of 85
+==2317516==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2317516==    by 0x109CA8: ft_new_token_node (tokenize.c:94)
+==2317516==    by 0x10A056: ft_tokenize (tokenize.c:174)
+==2317516==    by 0x10A1CC: ft_parse (tokenize.c:295)
+==2317516==    by 0x10A7CD: ft_read_line (parser.c:50)
+==2317516==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2317516==    by 0x1094BF: main (main.c:18)
+==2317516== 
+==2317516== LEAK SUMMARY:
+==2317516==    definitely lost: 192 bytes in 4 blocks
+==2317516==    indirectly lost: 63 bytes in 6 blocks
+==2317516==      possibly lost: 0 bytes in 0 blocks
+==2317516==    still reachable: 214,724 bytes in 266 blocks
+==2317516==         suppressed: 0 bytes in 0 blocks
+==2317516== Reachable blocks (those to which a pointer was found) are not shown.
+==2317516== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2317516== 
+==2317516== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-04T15:56:36+02:00 b/error_managment/valgrind/2025-04-04T15:56:36+02:00
new file mode 100644
index 0000000..63b4a44
--- /dev/null
+++ b/error_managment/valgrind/2025-04-04T15:56:36+02:00
@@ -0,0 +1,33 @@
+==2317850== Memcheck, a memory error detector
+==2317850== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2317850== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2317850== Command: ./minishell
+==2317850== Parent PID: 2317792
+==2317850== 
+==2317850== 
+==2317850== Process terminating with default action of signal 1 (SIGHUP)
+==2317850==    at 0x490875B: kill (syscall-template.S:120)
+==2317850==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317850==    by 0x48A25ED: rl_cleanup_after_signal (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317850==    by 0x48A5F9B: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317850==    by 0x48A642E: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317850==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317850==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2317850==    by 0x10A771: ft_read_line (parser.c:43)
+==2317850==    by 0x10A850: ft_start_minishell (parser.c:70)
+==2317850==    by 0x1094BF: main (main.c:18)
+==2317850== 
+==2317850== HEAP SUMMARY:
+==2317850==     in use at exit: 214,511 bytes in 252 blocks
+==2317850==   total heap usage: 479 allocs, 227 frees, 229,595 bytes allocated
+==2317850== 
+==2317850== LEAK SUMMARY:
+==2317850==    definitely lost: 0 bytes in 0 blocks
+==2317850==    indirectly lost: 0 bytes in 0 blocks
+==2317850==      possibly lost: 0 bytes in 0 blocks
+==2317850==    still reachable: 214,511 bytes in 252 blocks
+==2317850==         suppressed: 0 bytes in 0 blocks
+==2317850== Reachable blocks (those to which a pointer was found) are not shown.
+==2317850== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2317850== 
+==2317850== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:11:20+02:00 b/error_managment/valgrind/2025-04-07T12:11:20+02:00
new file mode 100644
index 0000000..519088d
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:11:20+02:00
@@ -0,0 +1,38 @@
+==2570844== Memcheck, a memory error detector
+==2570844== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2570844== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2570844== Command: ./minishell
+==2570844== Parent PID: 2570835
+==2570844== 
+==2570844== 
+==2570844== Process terminating with default action of signal 2 (SIGINT)
+==2570844==    at 0x49B03EA: wait4 (wait4.c:30)
+==2570844==    by 0x10AB98: execute_command (exec.c:18)
+==2570844==    by 0x10B167: execute_ast (exec.c:205)
+==2570844==    by 0x10AAA8: ft_read_line (parser.c:61)
+==2570844==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2570844==    by 0x1094DF: main (main.c:18)
+==2570844== 
+==2570844== HEAP SUMMARY:
+==2570844==     in use at exit: 214,573 bytes in 258 blocks
+==2570844==   total heap usage: 524 allocs, 266 frees, 230,165 bytes allocated
+==2570844== 
+==2570844== 54 (48 direct, 6 indirect) bytes in 1 blocks are definitely lost in loss record 30 of 85
+==2570844==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2570844==    by 0x109CC8: ft_new_token_node (tokenize.c:95)
+==2570844==    by 0x10A158: ft_tokenize (tokenize.c:196)
+==2570844==    by 0x10A453: ft_parse (tokenize.c:344)
+==2570844==    by 0x10AA54: ft_read_line (parser.c:50)
+==2570844==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2570844==    by 0x1094DF: main (main.c:18)
+==2570844== 
+==2570844== LEAK SUMMARY:
+==2570844==    definitely lost: 48 bytes in 1 blocks
+==2570844==    indirectly lost: 6 bytes in 1 blocks
+==2570844==      possibly lost: 0 bytes in 0 blocks
+==2570844==    still reachable: 214,519 bytes in 256 blocks
+==2570844==         suppressed: 0 bytes in 0 blocks
+==2570844== Reachable blocks (those to which a pointer was found) are not shown.
+==2570844== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2570844== 
+==2570844== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:11:35+02:00 b/error_managment/valgrind/2025-04-07T12:11:35+02:00
new file mode 100644
index 0000000..e2420f4
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:11:35+02:00
@@ -0,0 +1,32 @@
+==2571254== Memcheck, a memory error detector
+==2571254== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2571254== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2571254== Command: ./minishell
+==2571254== Parent PID: 2570980
+==2571254== 
+==2571254== 
+==2571254== Process terminating with default action of signal 2 (SIGINT)
+==2571254==    at 0x490875B: kill (syscall-template.S:120)
+==2571254==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571254==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571254==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571254==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571254==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571254==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2571254==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2571254==    by 0x1094DF: main (main.c:18)
+==2571254== 
+==2571254== HEAP SUMMARY:
+==2571254==     in use at exit: 210,365 bytes in 246 blocks
+==2571254==   total heap usage: 427 allocs, 181 frees, 224,700 bytes allocated
+==2571254== 
+==2571254== LEAK SUMMARY:
+==2571254==    definitely lost: 0 bytes in 0 blocks
+==2571254==    indirectly lost: 0 bytes in 0 blocks
+==2571254==      possibly lost: 0 bytes in 0 blocks
+==2571254==    still reachable: 210,365 bytes in 246 blocks
+==2571254==         suppressed: 0 bytes in 0 blocks
+==2571254== Reachable blocks (those to which a pointer was found) are not shown.
+==2571254== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2571254== 
+==2571254== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:12:35+02:00 b/error_managment/valgrind/2025-04-07T12:12:35+02:00
new file mode 100644
index 0000000..8eb38f0
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:12:35+02:00
@@ -0,0 +1,21 @@
+==2571325== Memcheck, a memory error detector
+==2571325== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2571325== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2571325== Command: ./minishell
+==2571325== Parent PID: 2571300
+==2571325== 
+==2571325== 
+==2571325== HEAP SUMMARY:
+==2571325==     in use at exit: 204,165 bytes in 221 blocks
+==2571325==   total heap usage: 427 allocs, 206 frees, 224,700 bytes allocated
+==2571325== 
+==2571325== LEAK SUMMARY:
+==2571325==    definitely lost: 0 bytes in 0 blocks
+==2571325==    indirectly lost: 0 bytes in 0 blocks
+==2571325==      possibly lost: 0 bytes in 0 blocks
+==2571325==    still reachable: 204,165 bytes in 221 blocks
+==2571325==         suppressed: 0 bytes in 0 blocks
+==2571325== Reachable blocks (those to which a pointer was found) are not shown.
+==2571325== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2571325== 
+==2571325== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:12:52+02:00 b/error_managment/valgrind/2025-04-07T12:12:52+02:00
new file mode 100644
index 0000000..693a1b9
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:12:52+02:00
@@ -0,0 +1,32 @@
+==2571452== Memcheck, a memory error detector
+==2571452== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2571452== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2571452== Command: ./minishell
+==2571452== Parent PID: 2571443
+==2571452== 
+==2571452== 
+==2571452== Process terminating with default action of signal 2 (SIGINT)
+==2571452==    at 0x490875B: kill (syscall-template.S:120)
+==2571452==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571452==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571452==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571452==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571452==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571452==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2571452==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2571452==    by 0x1094DF: main (main.c:18)
+==2571452== 
+==2571452== HEAP SUMMARY:
+==2571452==     in use at exit: 210,365 bytes in 246 blocks
+==2571452==   total heap usage: 427 allocs, 181 frees, 224,700 bytes allocated
+==2571452== 
+==2571452== LEAK SUMMARY:
+==2571452==    definitely lost: 0 bytes in 0 blocks
+==2571452==    indirectly lost: 0 bytes in 0 blocks
+==2571452==      possibly lost: 0 bytes in 0 blocks
+==2571452==    still reachable: 210,365 bytes in 246 blocks
+==2571452==         suppressed: 0 bytes in 0 blocks
+==2571452== Reachable blocks (those to which a pointer was found) are not shown.
+==2571452== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2571452== 
+==2571452== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:13:34+02:00 b/error_managment/valgrind/2025-04-07T12:13:34+02:00
new file mode 100644
index 0000000..fa152a3
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:13:34+02:00
@@ -0,0 +1,32 @@
+==2571652== Memcheck, a memory error detector
+==2571652== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2571652== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2571652== Command: ./minishell
+==2571652== Parent PID: 2571640
+==2571652== 
+==2571652== 
+==2571652== Process terminating with default action of signal 2 (SIGINT)
+==2571652==    at 0x490875B: kill (syscall-template.S:120)
+==2571652==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571652==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571652==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571652==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571652==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571652==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2571652==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2571652==    by 0x1094DF: main (main.c:18)
+==2571652== 
+==2571652== HEAP SUMMARY:
+==2571652==     in use at exit: 210,365 bytes in 246 blocks
+==2571652==   total heap usage: 427 allocs, 181 frees, 224,700 bytes allocated
+==2571652== 
+==2571652== LEAK SUMMARY:
+==2571652==    definitely lost: 0 bytes in 0 blocks
+==2571652==    indirectly lost: 0 bytes in 0 blocks
+==2571652==      possibly lost: 0 bytes in 0 blocks
+==2571652==    still reachable: 210,365 bytes in 246 blocks
+==2571652==         suppressed: 0 bytes in 0 blocks
+==2571652== Reachable blocks (those to which a pointer was found) are not shown.
+==2571652== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2571652== 
+==2571652== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:14:12+02:00 b/error_managment/valgrind/2025-04-07T12:14:12+02:00
new file mode 100644
index 0000000..3dc5fe0
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:14:12+02:00
@@ -0,0 +1,68 @@
+==2571971== Memcheck, a memory error detector
+==2571971== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2571971== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2571971== Command: ./minishell
+==2571971== Parent PID: 2571962
+==2571971== 
+==2571971== 
+==2571971== Process terminating with default action of signal 2 (SIGINT)
+==2571971==    at 0x490875B: kill (syscall-template.S:120)
+==2571971==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2571971==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2571971==    by 0x1094DF: main (main.c:18)
+==2571971== 
+==2571971== HEAP SUMMARY:
+==2571971==     in use at exit: 214,639 bytes in 261 blocks
+==2571971==   total heap usage: 516 allocs, 255 frees, 230,090 bytes allocated
+==2571971== 
+==2571971== 12 bytes in 1 blocks are possibly lost in loss record 11 of 86
+==2571971==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2571971==    by 0x490B03F: __add_to_environ (setenv.c:217)
+==2571971==    by 0x48543FF: setenv (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2571971==    by 0x48A5AF7: _rl_get_screen_size (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x4898AB8: ??? (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x4898E0D: rl_expand_prompt (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x48881BF: rl_set_prompt (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x4893CCF: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2571971==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2571971==    by 0x1094DF: main (main.c:18)
+==2571971== 
+==2571971== 24 bytes in 1 blocks are possibly lost in loss record 22 of 86
+==2571971==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2571971==    by 0x49E5F9E: tsearch (tsearch.c:337)
+==2571971==    by 0x490B06A: __add_to_environ (setenv.c:233)
+==2571971==    by 0x48543FF: setenv (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2571971==    by 0x48A5AF7: _rl_get_screen_size (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x4898AB8: ??? (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x4898E0D: rl_expand_prompt (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x48881BF: rl_set_prompt (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x4893CCF: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2571971==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2571971==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2571971==    by 0x1094DF: main (main.c:18)
+==2571971== 
+==2571971== 51 (48 direct, 3 indirect) bytes in 1 blocks are definitely lost in loss record 31 of 86
+==2571971==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2571971==    by 0x109CC8: ft_new_token_node (tokenize.c:95)
+==2571971==    by 0x10A158: ft_tokenize (tokenize.c:196)
+==2571971==    by 0x10A453: ft_parse (tokenize.c:344)
+==2571971==    by 0x10AA54: ft_read_line (parser.c:50)
+==2571971==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2571971==    by 0x1094DF: main (main.c:18)
+==2571971== 
+==2571971== LEAK SUMMARY:
+==2571971==    definitely lost: 48 bytes in 1 blocks
+==2571971==    indirectly lost: 3 bytes in 1 blocks
+==2571971==      possibly lost: 36 bytes in 2 blocks
+==2571971==    still reachable: 214,552 bytes in 257 blocks
+==2571971==         suppressed: 0 bytes in 0 blocks
+==2571971== Reachable blocks (those to which a pointer was found) are not shown.
+==2571971== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2571971== 
+==2571971== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:15:38+02:00 b/error_managment/valgrind/2025-04-07T12:15:38+02:00
new file mode 100644
index 0000000..053990e
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:15:38+02:00
@@ -0,0 +1,32 @@
+==2572327== Memcheck, a memory error detector
+==2572327== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2572327== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2572327== Command: ./minishell
+==2572327== Parent PID: 2572318
+==2572327== 
+==2572327== 
+==2572327== Process terminating with default action of signal 2 (SIGINT)
+==2572327==    at 0x490875B: kill (syscall-template.S:120)
+==2572327==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572327==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572327==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572327==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572327==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572327==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2572327==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2572327==    by 0x1094DF: main (main.c:18)
+==2572327== 
+==2572327== HEAP SUMMARY:
+==2572327==     in use at exit: 210,365 bytes in 246 blocks
+==2572327==   total heap usage: 427 allocs, 181 frees, 224,700 bytes allocated
+==2572327== 
+==2572327== LEAK SUMMARY:
+==2572327==    definitely lost: 0 bytes in 0 blocks
+==2572327==    indirectly lost: 0 bytes in 0 blocks
+==2572327==      possibly lost: 0 bytes in 0 blocks
+==2572327==    still reachable: 210,365 bytes in 246 blocks
+==2572327==         suppressed: 0 bytes in 0 blocks
+==2572327== Reachable blocks (those to which a pointer was found) are not shown.
+==2572327== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2572327== 
+==2572327== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:16:40+02:00 b/error_managment/valgrind/2025-04-07T12:16:40+02:00
new file mode 100644
index 0000000..6823db8
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:16:40+02:00
@@ -0,0 +1,32 @@
+==2572695== Memcheck, a memory error detector
+==2572695== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2572695== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2572695== Command: ./minishell
+==2572695== Parent PID: 2572686
+==2572695== 
+==2572695== 
+==2572695== Process terminating with default action of signal 2 (SIGINT)
+==2572695==    at 0x490875B: kill (syscall-template.S:120)
+==2572695==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572695==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572695==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572695==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572695==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2572695==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2572695==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2572695==    by 0x1094DF: main (main.c:18)
+==2572695== 
+==2572695== HEAP SUMMARY:
+==2572695==     in use at exit: 214,471 bytes in 252 blocks
+==2572695==   total heap usage: 470 allocs, 218 frees, 229,343 bytes allocated
+==2572695== 
+==2572695== LEAK SUMMARY:
+==2572695==    definitely lost: 0 bytes in 0 blocks
+==2572695==    indirectly lost: 0 bytes in 0 blocks
+==2572695==      possibly lost: 0 bytes in 0 blocks
+==2572695==    still reachable: 214,471 bytes in 252 blocks
+==2572695==         suppressed: 0 bytes in 0 blocks
+==2572695== Reachable blocks (those to which a pointer was found) are not shown.
+==2572695== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2572695== 
+==2572695== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:24:01+02:00 b/error_managment/valgrind/2025-04-07T12:24:01+02:00
new file mode 100644
index 0000000..eee0a6d
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:24:01+02:00
@@ -0,0 +1,32 @@
+==2574862== Memcheck, a memory error detector
+==2574862== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2574862== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2574862== Command: ./minishell
+==2574862== Parent PID: 2574853
+==2574862== 
+==2574862== 
+==2574862== Process terminating with default action of signal 2 (SIGINT)
+==2574862==    at 0x490875B: kill (syscall-template.S:120)
+==2574862==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2574862==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2574862==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2574862==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2574862==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2574862==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2574862==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2574862==    by 0x1094DF: main (main.c:18)
+==2574862== 
+==2574862== HEAP SUMMARY:
+==2574862==     in use at exit: 214,463 bytes in 252 blocks
+==2574862==   total heap usage: 470 allocs, 218 frees, 229,327 bytes allocated
+==2574862== 
+==2574862== LEAK SUMMARY:
+==2574862==    definitely lost: 0 bytes in 0 blocks
+==2574862==    indirectly lost: 0 bytes in 0 blocks
+==2574862==      possibly lost: 0 bytes in 0 blocks
+==2574862==    still reachable: 214,463 bytes in 252 blocks
+==2574862==         suppressed: 0 bytes in 0 blocks
+==2574862== Reachable blocks (those to which a pointer was found) are not shown.
+==2574862== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2574862== 
+==2574862== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:24:35+02:00 b/error_managment/valgrind/2025-04-07T12:24:35+02:00
new file mode 100644
index 0000000..ef22ec9
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:24:35+02:00
@@ -0,0 +1,32 @@
+==2575052== Memcheck, a memory error detector
+==2575052== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2575052== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2575052== Command: ./minishell
+==2575052== Parent PID: 2575043
+==2575052== 
+==2575052== 
+==2575052== Process terminating with default action of signal 2 (SIGINT)
+==2575052==    at 0x490875B: kill (syscall-template.S:120)
+==2575052==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575052==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575052==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575052==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575052==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575052==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2575052==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2575052==    by 0x1094DF: main (main.c:18)
+==2575052== 
+==2575052== HEAP SUMMARY:
+==2575052==     in use at exit: 210,357 bytes in 246 blocks
+==2575052==   total heap usage: 427 allocs, 181 frees, 224,684 bytes allocated
+==2575052== 
+==2575052== LEAK SUMMARY:
+==2575052==    definitely lost: 0 bytes in 0 blocks
+==2575052==    indirectly lost: 0 bytes in 0 blocks
+==2575052==      possibly lost: 0 bytes in 0 blocks
+==2575052==    still reachable: 210,357 bytes in 246 blocks
+==2575052==         suppressed: 0 bytes in 0 blocks
+==2575052== Reachable blocks (those to which a pointer was found) are not shown.
+==2575052== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2575052== 
+==2575052== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:24:58+02:00 b/error_managment/valgrind/2025-04-07T12:24:58+02:00
new file mode 100644
index 0000000..02e2b2f
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:24:58+02:00
@@ -0,0 +1,32 @@
+==2575157== Memcheck, a memory error detector
+==2575157== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2575157== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2575157== Command: ./minishell
+==2575157== Parent PID: 2575142
+==2575157== 
+==2575157== 
+==2575157== Process terminating with default action of signal 2 (SIGINT)
+==2575157==    at 0x490875B: kill (syscall-template.S:120)
+==2575157==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575157==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575157==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575157==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575157==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575157==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2575157==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2575157==    by 0x1094DF: main (main.c:18)
+==2575157== 
+==2575157== HEAP SUMMARY:
+==2575157==     in use at exit: 210,365 bytes in 246 blocks
+==2575157==   total heap usage: 428 allocs, 182 frees, 224,732 bytes allocated
+==2575157== 
+==2575157== LEAK SUMMARY:
+==2575157==    definitely lost: 0 bytes in 0 blocks
+==2575157==    indirectly lost: 0 bytes in 0 blocks
+==2575157==      possibly lost: 0 bytes in 0 blocks
+==2575157==    still reachable: 210,365 bytes in 246 blocks
+==2575157==         suppressed: 0 bytes in 0 blocks
+==2575157== Reachable blocks (those to which a pointer was found) are not shown.
+==2575157== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2575157== 
+==2575157== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:27:48+02:00 b/error_managment/valgrind/2025-04-07T12:27:48+02:00
new file mode 100644
index 0000000..9850f95
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:27:48+02:00
@@ -0,0 +1,32 @@
+==2575824== Memcheck, a memory error detector
+==2575824== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2575824== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2575824== Command: ./minishell
+==2575824== Parent PID: 2575768
+==2575824== 
+==2575824== 
+==2575824== Process terminating with default action of signal 2 (SIGINT)
+==2575824==    at 0x490875B: kill (syscall-template.S:120)
+==2575824==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575824==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575824==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575824==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575824==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2575824==    by 0x10A9F8: ft_read_line (parser.c:43)
+==2575824==    by 0x10AAD7: ft_start_minishell (parser.c:70)
+==2575824==    by 0x1094DF: main (main.c:18)
+==2575824== 
+==2575824== HEAP SUMMARY:
+==2575824==     in use at exit: 210,373 bytes in 246 blocks
+==2575824==   total heap usage: 427 allocs, 181 frees, 224,716 bytes allocated
+==2575824== 
+==2575824== LEAK SUMMARY:
+==2575824==    definitely lost: 0 bytes in 0 blocks
+==2575824==    indirectly lost: 0 bytes in 0 blocks
+==2575824==      possibly lost: 0 bytes in 0 blocks
+==2575824==    still reachable: 210,373 bytes in 246 blocks
+==2575824==         suppressed: 0 bytes in 0 blocks
+==2575824== Reachable blocks (those to which a pointer was found) are not shown.
+==2575824== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2575824== 
+==2575824== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:29:02+02:00 b/error_managment/valgrind/2025-04-07T12:29:02+02:00
new file mode 100644
index 0000000..1dfeb1e
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:29:02+02:00
@@ -0,0 +1,21 @@
+==2576148== Memcheck, a memory error detector
+==2576148== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2576148== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2576148== Command: ./minishell
+==2576148== Parent PID: 2576140
+==2576148== 
+==2576148== 
+==2576148== HEAP SUMMARY:
+==2576148==     in use at exit: 204,165 bytes in 221 blocks
+==2576148==   total heap usage: 427 allocs, 206 frees, 224,732 bytes allocated
+==2576148== 
+==2576148== LEAK SUMMARY:
+==2576148==    definitely lost: 0 bytes in 0 blocks
+==2576148==    indirectly lost: 0 bytes in 0 blocks
+==2576148==      possibly lost: 0 bytes in 0 blocks
+==2576148==    still reachable: 204,165 bytes in 221 blocks
+==2576148==         suppressed: 0 bytes in 0 blocks
+==2576148== Reachable blocks (those to which a pointer was found) are not shown.
+==2576148== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2576148== 
+==2576148== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T12:32:00+02:00 b/error_managment/valgrind/2025-04-07T12:32:00+02:00
new file mode 100644
index 0000000..1a585a4
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T12:32:00+02:00
@@ -0,0 +1,41 @@
+==2577121== Memcheck, a memory error detector
+==2577121== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2577121== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2577121== Command: ./minishell
+==2577121== Parent PID: 2577113
+==2577121== 
+==2577121== 
+==2577121== Process terminating with default action of signal 2 (SIGINT)
+==2577121==    at 0x490875B: kill (syscall-template.S:120)
+==2577121==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2577121==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2577121==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2577121==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2577121==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2577121==    by 0x10ADCF: ft_read_line (parser.c:43)
+==2577121==    by 0x10AEA0: ft_start_minishell (parser.c:71)
+==2577121==    by 0x109482: main (main.c:24)
+==2577121== 
+==2577121== HEAP SUMMARY:
+==2577121==     in use at exit: 214,529 bytes in 260 blocks
+==2577121==   total heap usage: 553 allocs, 293 frees, 230,646 bytes allocated
+==2577121== 
+==2577121== 102 (96 direct, 6 indirect) bytes in 2 blocks are definitely lost in loss record 31 of 82
+==2577121==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2577121==    by 0x109FD9: ft_new_token_node (tokenize.c:94)
+==2577121==    by 0x10A387: ft_tokenize (tokenize.c:174)
+==2577121==    by 0x10A59F: ft_parse (tokenize.c:236)
+==2577121==    by 0x10AE2B: ft_read_line (parser.c:50)
+==2577121==    by 0x10AEA0: ft_start_minishell (parser.c:71)
+==2577121==    by 0x109482: main (main.c:24)
+==2577121== 
+==2577121== LEAK SUMMARY:
+==2577121==    definitely lost: 96 bytes in 2 blocks
+==2577121==    indirectly lost: 6 bytes in 2 blocks
+==2577121==      possibly lost: 0 bytes in 0 blocks
+==2577121==    still reachable: 214,427 bytes in 256 blocks
+==2577121==         suppressed: 0 bytes in 0 blocks
+==2577121== Reachable blocks (those to which a pointer was found) are not shown.
+==2577121== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2577121== 
+==2577121== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T13:15:18+02:00 b/error_managment/valgrind/2025-04-07T13:15:18+02:00
new file mode 100644
index 0000000..8ea0540
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T13:15:18+02:00
@@ -0,0 +1,30 @@
+==2589123== Memcheck, a memory error detector
+==2589123== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2589123== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2589123== Command: ./minishell
+==2589123== Parent PID: 2589115
+==2589123== 
+==2589123== 
+==2589123== HEAP SUMMARY:
+==2589123==     in use at exit: 208,281 bytes in 227 blocks
+==2589123==   total heap usage: 485 allocs, 258 frees, 229,594 bytes allocated
+==2589123== 
+==2589123== 54 (48 direct, 6 indirect) bytes in 1 blocks are definitely lost in loss record 20 of 68
+==2589123==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589123==    by 0x10A14C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589123==    by 0x10A4FA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589123==    by 0x10A712: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589123==    by 0x10AF9E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589123==    by 0x10B041: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589123==    by 0x10957D: main (main.c:24)
+==2589123== 
+==2589123== LEAK SUMMARY:
+==2589123==    definitely lost: 48 bytes in 1 blocks
+==2589123==    indirectly lost: 6 bytes in 1 blocks
+==2589123==      possibly lost: 0 bytes in 0 blocks
+==2589123==    still reachable: 208,227 bytes in 225 blocks
+==2589123==         suppressed: 0 bytes in 0 blocks
+==2589123== Reachable blocks (those to which a pointer was found) are not shown.
+==2589123== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2589123== 
+==2589123== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T13:20:22+02:00 b/error_managment/valgrind/2025-04-07T13:20:22+02:00
new file mode 100644
index 0000000..db4f9f5
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T13:20:22+02:00
@@ -0,0 +1,283 @@
+==2589987== Memcheck, a memory error detector
+==2589987== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2589987== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2589987== Command: ./minishell
+==2589987== Parent PID: 2589979
+==2589987== 
+==2589987== Invalid read of size 4
+==2589987==    at 0x10A59D: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa1c is 12 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== Invalid read of size 8
+==2589987==    at 0x10A5AD: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== Invalid read of size 8
+==2589987==    at 0x10A5E8: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== Invalid read of size 8
+==2589987==    at 0x10A607: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== Invalid write of size 8
+==2589987==    at 0x10A61A: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== 
+==2589987== Process terminating with default action of signal 6 (SIGABRT)
+==2589987==    at 0x495C9FC: __pthread_kill_implementation (pthread_kill.c:44)
+==2589987==    by 0x495C9FC: __pthread_kill_internal (pthread_kill.c:78)
+==2589987==    by 0x495C9FC: pthread_kill@@GLIBC_2.34 (pthread_kill.c:89)
+==2589987==    by 0x4908475: raise (raise.c:26)
+==2589987==    by 0x48EE7F2: abort (abort.c:79)
+==2589987==    by 0x48EE71A: __assert_fail_base.cold (assert.c:94)
+==2589987==    by 0x48FFE95: __assert_fail (assert.c:103)
+==2589987==    by 0x10BF31: execute_ast (exec.c:205)
+==2589987==    by 0x10AFC3: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== HEAP SUMMARY:
+==2589987==     in use at exit: 214,682 bytes in 260 blocks
+==2589987==   total heap usage: 876 allocs, 616 frees, 333,544 bytes allocated
+==2589987== 
+==2589987== 11 bytes in 1 blocks are definitely lost in loss record 5 of 86
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A5D8: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== 14 bytes in 2 blocks are definitely lost in loss record 14 of 86
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10C034: ft_strdup (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A12A: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== LEAK SUMMARY:
+==2589987==    definitely lost: 25 bytes in 3 blocks
+==2589987==    indirectly lost: 0 bytes in 0 blocks
+==2589987==      possibly lost: 0 bytes in 0 blocks
+==2589987==    still reachable: 214,657 bytes in 257 blocks
+==2589987==         suppressed: 0 bytes in 0 blocks
+==2589987== Reachable blocks (those to which a pointer was found) are not shown.
+==2589987== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2589987== 
+==2589987== ERROR SUMMARY: 7 errors from 7 contexts (suppressed: 0 from 0)
+==2589987== 
+==2589987== 1 errors in context 1 of 7:
+==2589987== Invalid write of size 8
+==2589987==    at 0x10A61A: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== 
+==2589987== 1 errors in context 2 of 7:
+==2589987== Invalid read of size 8
+==2589987==    at 0x10A607: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== 
+==2589987== 1 errors in context 3 of 7:
+==2589987== Invalid read of size 8
+==2589987==    at 0x10A5E8: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== 
+==2589987== 1 errors in context 4 of 7:
+==2589987== Invalid read of size 8
+==2589987==    at 0x10A5AD: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa10 is 0 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== 
+==2589987== 1 errors in context 5 of 7:
+==2589987== Invalid read of size 4
+==2589987==    at 0x10A59D: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Address 0x4b7fa1c is 12 bytes inside a block of size 48 free'd
+==2589987==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A628: ft_create_ast (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6F0: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987==  Block was alloc'd at
+==2589987==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
+==2589987==    by 0x10A10C: ft_new_token_node (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A4BA: ft_tokenize (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10A6D2: ft_parse (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10AF5E: ft_read_line (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10B001: ft_start_minishell (in /home/cbouhadr/Documents/minishell/minishell)
+==2589987==    by 0x10953D: main (main.c:24)
+==2589987== 
+==2589987== ERROR SUMMARY: 7 errors from 7 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T13:21:41+02:00 b/error_managment/valgrind/2025-04-07T13:21:41+02:00
new file mode 100644
index 0000000..e27f1ab
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T13:21:41+02:00
@@ -0,0 +1,21 @@
+==2590459== Memcheck, a memory error detector
+==2590459== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2590459== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2590459== Command: ./minishell
+==2590459== Parent PID: 2590451
+==2590459== 
+==2590459== 
+==2590459== HEAP SUMMARY:
+==2590459==     in use at exit: 204,169 bytes in 221 blocks
+==2590459==   total heap usage: 427 allocs, 206 frees, 224,736 bytes allocated
+==2590459== 
+==2590459== LEAK SUMMARY:
+==2590459==    definitely lost: 0 bytes in 0 blocks
+==2590459==    indirectly lost: 0 bytes in 0 blocks
+==2590459==      possibly lost: 0 bytes in 0 blocks
+==2590459==    still reachable: 204,169 bytes in 221 blocks
+==2590459==         suppressed: 0 bytes in 0 blocks
+==2590459== Reachable blocks (those to which a pointer was found) are not shown.
+==2590459== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2590459== 
+==2590459== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T13:49:59+02:00 b/error_managment/valgrind/2025-04-07T13:49:59+02:00
new file mode 100644
index 0000000..5806aa4
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T13:49:59+02:00
@@ -0,0 +1,21 @@
+==2597433== Memcheck, a memory error detector
+==2597433== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2597433== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2597433== Command: ./minishell
+==2597433== Parent PID: 2597425
+==2597433== 
+==2597433== 
+==2597433== HEAP SUMMARY:
+==2597433==     in use at exit: 204,169 bytes in 221 blocks
+==2597433==   total heap usage: 427 allocs, 206 frees, 224,752 bytes allocated
+==2597433== 
+==2597433== LEAK SUMMARY:
+==2597433==    definitely lost: 0 bytes in 0 blocks
+==2597433==    indirectly lost: 0 bytes in 0 blocks
+==2597433==      possibly lost: 0 bytes in 0 blocks
+==2597433==    still reachable: 204,169 bytes in 221 blocks
+==2597433==         suppressed: 0 bytes in 0 blocks
+==2597433== Reachable blocks (those to which a pointer was found) are not shown.
+==2597433== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2597433== 
+==2597433== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/error_managment/valgrind/2025-04-07T13:54:19+02:00 b/error_managment/valgrind/2025-04-07T13:54:19+02:00
new file mode 100644
index 0000000..98e16c2
--- /dev/null
+++ b/error_managment/valgrind/2025-04-07T13:54:19+02:00
@@ -0,0 +1,32 @@
+==2599567== Memcheck, a memory error detector
+==2599567== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==2599567== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==2599567== Command: ./minishell
+==2599567== Parent PID: 2599559
+==2599567== 
+==2599567== 
+==2599567== Process terminating with default action of signal 2 (SIGINT)
+==2599567==    at 0x490875B: kill (syscall-template.S:120)
+==2599567==    by 0x48A5F39: _rl_signal_handler (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2599567==    by 0x48A6BEC: rl_getc (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2599567==    by 0x48A6460: rl_read_key (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2599567==    by 0x488AC86: readline_internal_char (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2599567==    by 0x4893D14: readline (in /usr/lib/x86_64-linux-gnu/libreadline.so.8.1)
+==2599567==    by 0x10AF02: ft_read_line (parser.c:43)
+==2599567==    by 0x10AFE1: ft_start_minishell (parser.c:70)
+==2599567==    by 0x10953D: main (main.c:24)
+==2599567== 
+==2599567== HEAP SUMMARY:
+==2599567==     in use at exit: 210,393 bytes in 246 blocks
+==2599567==   total heap usage: 427 allocs, 181 frees, 224,752 bytes allocated
+==2599567== 
+==2599567== LEAK SUMMARY:
+==2599567==    definitely lost: 0 bytes in 0 blocks
+==2599567==    indirectly lost: 0 bytes in 0 blocks
+==2599567==      possibly lost: 0 bytes in 0 blocks
+==2599567==    still reachable: 210,393 bytes in 246 blocks
+==2599567==         suppressed: 0 bytes in 0 blocks
+==2599567== Reachable blocks (those to which a pointer was found) are not shown.
+==2599567== To see them, rerun with: --leak-check=full --show-leak-kinds=all
+==2599567== 
+==2599567== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/include/main.h b/include/main.h
index e8c8317..e6bf125 100644
--- a/include/main.h
+++ b/include/main.h
@@ -6,7 +6,7 @@
 /*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/13 22:15:28 by cw3l              #+#    #+#             */
-/*   Updated: 2025/03/25 12:23:36 by cw3l             ###   ########.fr       */
+/*   Updated: 2025/04/02 08:51:24 by cw3l             ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -26,12 +26,15 @@
 #include <dirent.h>
 #include <stdio.h>
 #include <assert.h>
-
+#include <signal.h>
 
 #include "../srcs/exec/exec.h"
 #include "../srcs/parser/parser.h"
 //#include "../srcs/parser/tokenizer/tokenize.h" circular include issues
 #include "../libft/libft.h"
+#include "../srcs/builtin/builtin.h"
+#include "../srcs/execution/execution.h"
+#include "../srcs/parser/tokenizer/tokenize.h"
 
 #include <string.h>
 
diff --git a/libft/Makefile b/libft/Makefile
index b24fba7..39f47e1 100644
--- a/libft/Makefile
+++ b/libft/Makefile
@@ -37,6 +37,7 @@ SRCS=	ft_putchar_fd.c \
 		ft_split.c \
 		ft_split_len.c \
 		ft_split_clean.c \
+		ft_split_print.c \
 		ft_strncmp.c \
 		ft_itoa.c \
 		ft_atoi.c \
@@ -52,6 +53,9 @@ SRCS=	ft_putchar_fd.c \
 		ft_print_bit_64.c \
 		ft_index_of.c \
 		ft_get_max_value.c \
+		ft_split_quick_sort.c \
+		ft_split_is_sort.c \
+		ft_swap_str.c \
 
 BONUS=	ft_lstnew_bonus.c \
 		ft_lstadd_front_bonus.c \
@@ -76,7 +80,6 @@ ${NAME}: ${OBJS} ${HDRS}
 
 bonus: ${OBJS} ${BONUS_OBJS} ${HDRS}
 	${AR} ${NAME} ${OBJS} ${BONUS_OBJS}
-	make clean
 
 clean:
 	rm -rf *.o *.dSYM
diff --git a/libft/ft_atoi.o b/libft/ft_atoi.o
new file mode 100644
index 0000000..5cc8d35
Binary files /dev/null and b/libft/ft_atoi.o differ
diff --git a/libft/ft_bzero.o b/libft/ft_bzero.o
new file mode 100644
index 0000000..cf6215f
Binary files /dev/null and b/libft/ft_bzero.o differ
diff --git a/libft/ft_calloc.o b/libft/ft_calloc.o
new file mode 100644
index 0000000..8492ce2
Binary files /dev/null and b/libft/ft_calloc.o differ
diff --git a/libft/ft_cmp_char.o b/libft/ft_cmp_char.o
new file mode 100644
index 0000000..a84ffd6
Binary files /dev/null and b/libft/ft_cmp_char.o differ
diff --git a/libft/ft_cmp_int.o b/libft/ft_cmp_int.o
new file mode 100644
index 0000000..31f7932
Binary files /dev/null and b/libft/ft_cmp_int.o differ
diff --git a/libft/ft_get_max_value.o b/libft/ft_get_max_value.o
new file mode 100644
index 0000000..b49d323
Binary files /dev/null and b/libft/ft_get_max_value.o differ
diff --git a/libft/ft_index_of.o b/libft/ft_index_of.o
new file mode 100644
index 0000000..dd50a65
Binary files /dev/null and b/libft/ft_index_of.o differ
diff --git a/libft/ft_is_sort.o b/libft/ft_is_sort.o
new file mode 100644
index 0000000..6ee9722
Binary files /dev/null and b/libft/ft_is_sort.o differ
diff --git a/libft/ft_isalnum.o b/libft/ft_isalnum.o
new file mode 100644
index 0000000..12f1c69
Binary files /dev/null and b/libft/ft_isalnum.o differ
diff --git a/libft/ft_isalpha.o b/libft/ft_isalpha.o
new file mode 100644
index 0000000..cdd8acd
Binary files /dev/null and b/libft/ft_isalpha.o differ
diff --git a/libft/ft_isascii.o b/libft/ft_isascii.o
new file mode 100644
index 0000000..0c87c23
Binary files /dev/null and b/libft/ft_isascii.o differ
diff --git a/libft/ft_isdigit.o b/libft/ft_isdigit.o
new file mode 100644
index 0000000..8aa6b69
Binary files /dev/null and b/libft/ft_isdigit.o differ
diff --git a/libft/ft_isprint.o b/libft/ft_isprint.o
new file mode 100644
index 0000000..e3a203c
Binary files /dev/null and b/libft/ft_isprint.o differ
diff --git a/libft/ft_isset.o b/libft/ft_isset.o
new file mode 100644
index 0000000..562eec5
Binary files /dev/null and b/libft/ft_isset.o differ
diff --git a/libft/ft_itoa.o b/libft/ft_itoa.o
new file mode 100644
index 0000000..63bcb17
Binary files /dev/null and b/libft/ft_itoa.o differ
diff --git a/libft/ft_lstadd_back_bonus.o b/libft/ft_lstadd_back_bonus.o
new file mode 100644
index 0000000..2995a36
Binary files /dev/null and b/libft/ft_lstadd_back_bonus.o differ
diff --git a/libft/ft_lstadd_front_bonus.o b/libft/ft_lstadd_front_bonus.o
new file mode 100644
index 0000000..352fd7c
Binary files /dev/null and b/libft/ft_lstadd_front_bonus.o differ
diff --git a/libft/ft_lstclear_bonus.o b/libft/ft_lstclear_bonus.o
new file mode 100644
index 0000000..a76c624
Binary files /dev/null and b/libft/ft_lstclear_bonus.o differ
diff --git a/libft/ft_lstdelone_bonus.o b/libft/ft_lstdelone_bonus.o
new file mode 100644
index 0000000..672406b
Binary files /dev/null and b/libft/ft_lstdelone_bonus.o differ
diff --git a/libft/ft_lstiter_bonus.o b/libft/ft_lstiter_bonus.o
new file mode 100644
index 0000000..c06574b
Binary files /dev/null and b/libft/ft_lstiter_bonus.o differ
diff --git a/libft/ft_lstlast_bonus.o b/libft/ft_lstlast_bonus.o
new file mode 100644
index 0000000..8684632
Binary files /dev/null and b/libft/ft_lstlast_bonus.o differ
diff --git a/libft/ft_lstmap_bonus.o b/libft/ft_lstmap_bonus.o
new file mode 100644
index 0000000..a1f17f3
Binary files /dev/null and b/libft/ft_lstmap_bonus.o differ
diff --git a/libft/ft_lstnew_bonus.o b/libft/ft_lstnew_bonus.o
new file mode 100644
index 0000000..a7f95c0
Binary files /dev/null and b/libft/ft_lstnew_bonus.o differ
diff --git a/libft/ft_lstsize_bonus.o b/libft/ft_lstsize_bonus.o
new file mode 100644
index 0000000..787c61f
Binary files /dev/null and b/libft/ft_lstsize_bonus.o differ
diff --git a/libft/ft_memchr.o b/libft/ft_memchr.o
new file mode 100644
index 0000000..2c640fa
Binary files /dev/null and b/libft/ft_memchr.o differ
diff --git a/libft/ft_memcmp.o b/libft/ft_memcmp.o
new file mode 100644
index 0000000..37c852c
Binary files /dev/null and b/libft/ft_memcmp.o differ
diff --git a/libft/ft_memcpy.o b/libft/ft_memcpy.o
new file mode 100644
index 0000000..34adbfb
Binary files /dev/null and b/libft/ft_memcpy.o differ
diff --git a/libft/ft_memmove.o b/libft/ft_memmove.o
new file mode 100644
index 0000000..edff4da
Binary files /dev/null and b/libft/ft_memmove.o differ
diff --git a/libft/ft_memset.o b/libft/ft_memset.o
new file mode 100644
index 0000000..956e0f2
Binary files /dev/null and b/libft/ft_memset.o differ
diff --git a/libft/ft_print_bit_16.o b/libft/ft_print_bit_16.o
new file mode 100644
index 0000000..faa80fb
Binary files /dev/null and b/libft/ft_print_bit_16.o differ
diff --git a/libft/ft_print_bit_32.o b/libft/ft_print_bit_32.o
new file mode 100644
index 0000000..84030f8
Binary files /dev/null and b/libft/ft_print_bit_32.o differ
diff --git a/libft/ft_print_bit_64.o b/libft/ft_print_bit_64.o
new file mode 100644
index 0000000..7a84bcb
Binary files /dev/null and b/libft/ft_print_bit_64.o differ
diff --git a/libft/ft_print_bit_8.o b/libft/ft_print_bit_8.o
new file mode 100644
index 0000000..0cdf825
Binary files /dev/null and b/libft/ft_print_bit_8.o differ
diff --git a/libft/ft_putchar_fd.o b/libft/ft_putchar_fd.o
new file mode 100644
index 0000000..83d697d
Binary files /dev/null and b/libft/ft_putchar_fd.o differ
diff --git a/libft/ft_putendl_fd.o b/libft/ft_putendl_fd.o
new file mode 100644
index 0000000..ee1d373
Binary files /dev/null and b/libft/ft_putendl_fd.o differ
diff --git a/libft/ft_putnbr_fd.o b/libft/ft_putnbr_fd.o
new file mode 100644
index 0000000..ec973bb
Binary files /dev/null and b/libft/ft_putnbr_fd.o differ
diff --git a/libft/ft_putstr_fd.o b/libft/ft_putstr_fd.o
new file mode 100644
index 0000000..a85879a
Binary files /dev/null and b/libft/ft_putstr_fd.o differ
diff --git a/libft/ft_qsort.c b/libft/ft_qsort.c
index 8dec0b9..68a1953 100644
--- a/libft/ft_qsort.c
+++ b/libft/ft_qsort.c
@@ -6,70 +6,70 @@
 /*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2024/11/27 11:49:47 by cbouhadr          #+#    #+#             */
-/*   Updated: 2024/12/04 13:57:10 by cbouhadr         ###   ########.fr       */
+/*   Updated: 2025/04/02 14:46:57 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "libft.h"
 
-void ft_print(int *arr, int len)
-{
-	int j;
+// void ft_print(int *arr, int len)
+// {
+// 	int j;
 	
-	j = 0;
-	while (j < len)
-	{
-		printf(" %d", (int)arr[j]);
-		j++;
-	}
-	printf("\n");
-}
-int	ft_partition(void *arr, int end, int t, int (*cmp)(void *, void *))
-{
-	int				idx_pivot;
-	unsigned char 	*tab;
-	int				i;
-	int 			j;
+// 	j = 0;
+// 	while (j < len)
+// 	{
+// 		printf(" %d", (int)arr[j]);
+// 		j++;
+// 	}
+// 	printf("\n");
+// }
+// int	ft_partition(void *arr, int end, int t, int (*cmp)(void *, void *))
+// {
+// 	int				idx_pivot;
+// 	unsigned char 	*tab;
+// 	int				i;
+// 	int 			j;
 	
-	i = 0;
-	j = 0;
-	tab = (unsigned char *)arr;
+// 	i = 0;
+// 	j = 0;
+// 	tab = (unsigned char *)arr;
 
-	idx_pivot = (end - 1) * t;
-	while (j < (end - 1) * t)
-	{
-		if(cmp(&tab[i], &tab[j]) > 0)
-			ft_swap_ptr(&tab[i], &tab[j], t);
-		if(cmp(&tab[i], &tab[idx_pivot]) > 0)
-			j += t;
-		else
-		{	
-			i += t;
-			j += t;
-		}
-	}
+// 	idx_pivot = (end - 1) * t;
+// 	while (j < (end - 1) * t)
+// 	{
+// 		if(cmp(&tab[i], &tab[j]) > 0)
+// 			ft_swap_ptr(&tab[i], &tab[j], t);
+// 		if(cmp(&tab[i], &tab[idx_pivot]) > 0)
+// 			j += t;
+// 		else
+// 		{	
+// 			i += t;
+// 			j += t;
+// 		}
+// 	}
 	
-	return ((i / t));
-} 
+// 	return ((i / t));
+// } 
 
-void	ft_qsort(void *base, int nel, int width, int (*cmp)(void *, void *))
-{
-	int i;
-	int start;
-	int end;
+// void	ft_qsort(void *base, int nel, int width, int (*cmp)(void *, void *))
+// {
+// 	int i;
+// 	int start;
+// 	int end;
 
-	i = 0;
-	start = i;
-	end = (nel * width) - width;
+// 	i = 0;
+// 	start = i;
+// 	end = (nel * width) - width;
 	
-	if (nel <= 1)
-	 	return;
+// 	if (nel <= 1)
+// 	 	return;
 	
-	i = ft_partition(base, nel, width, cmp);
-	ft_qsort(base,i,width,cmp);
-	ft_qsort(&base[i], nel - i, width, cmp);
+// 	i = ft_partition(base, nel, width, cmp);
+// 	ft_qsort(base,i,width,cmp);
+// 	ft_qsort(&base[i], nel - i, width, cmp);
 	
-}
+// }
 
 // int  main(void)
 // {
@@ -77,7 +77,7 @@ void	ft_qsort(void *base, int nel, int width, int (*cmp)(void *, void *))
 // 	int arr[] = {14, 99, -22, 56, 77, 55};
 
 // 	int size = sizeof(arr) / sizeof(arr[0]);
-// 	ft_qsort(arr,size,4,ft_cmp_char);
+ 	ft_qsort(arr,size,4,ft_cmp_char);
 	
 // 	ft_print(arr,size);
 // 	return (0);
diff --git a/libft/ft_split.c b/libft/ft_split.c
index 3e66499..22092c2 100644
--- a/libft/ft_split.c
+++ b/libft/ft_split.c
@@ -3,107 +3,114 @@
 /*                                                        :::      ::::::::   */
 /*   ft_split.c                                         :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2024/10/02 14:53:35 by cbouhadr          #+#    #+#             */
-/*   Updated: 2024/10/12 17:15:22 by cbouhadr         ###   ########.fr       */
+/*   Updated: 2025/03/28 23:55:34 by cw3l             ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "libft.h"
+#include <assert.h>
 
-static size_t	count_word(char const *str, char c)
+static int	ft_clean_memory_exit(char ***split, int idx)
 {
-	size_t	i;
-	size_t	word_count;
-	size_t	is_word;
+	int	i;
 
 	i = 0;
-	word_count = 0;
-	is_word = 0;
-	while (str[i] && i < ft_strlen(str) - 1)
+	while (i < idx)
 	{
-		if (str[i] == c)
-		{
-			is_word = 0;
-			i++;
-		}
-		if (str[i] != c)
-		{
-			if (is_word == 0)
-				word_count++;
-			is_word = 1;
-			i++;
-		}
+		free(*split[i]);
+		*split[i] = NULL;
+		i++;
 	}
-	return (word_count);
+	free(*split);
+	*split = NULL;
+	return (0);
 }
 
-static void	ft_free(char **p, size_t index)
+int	ft_count_word(char const *str, char c)
 {
-	size_t	k;
+	int	i;
+	int	on;
+	int	count;
 
-	k = 0;
-	while (k <= index)
+	i = 0;
+	on = 0;
+	count = 0;
+	if (!str[i])
+		return (-1);
+	while (str[i])
 	{
-		p[k] = NULL;
-		free(p[k]);
-		k++;
+		if (str[i] != c && on == 0)
+		{
+			count++;
+			on = 1;
+		}
+		else if (str[i] == c)
+			on = 0;
+		i++;
 	}
-	p = NULL;
-	free(p);
+	return (count);
 }
 
-static void	check_alloc(char **ptr, size_t j)
+int	ft_get_word_len(char const *str, char c)
 {
-	if (!*ptr[j])
-		ft_free(ptr, j);
+	int	i;
+
+	i = 0;
+	if (!str)
+		return (0);
+	while (str[i] && str[i] != c)
+		i++;
+	return (i);
 }
 
-static char	**process_data(char **ptr, char const *s, char c, size_t nb_word)
+int	ft_process_data(char **split, char const *str, char c)
 {
-	size_t	i;
-	size_t	j;
-	size_t	len;
+	int	i;
+	int	j;
+	int	word_len;
 
-	j = 0;
 	i = 0;
-	while (j < nb_word)
+	j = 0;
+	while (str[i])
 	{
-		if (s[i] != c)
+		if (str[i] != c)
 		{
-			len = (ft_strchr(&s[i], c)) - &s[i];
-			if (len <= ft_strlen(s))
-			{
-				ptr[j] = ft_substr(&s[i], 0, len);
-				i = (len - 1) + i;
-			}
-			else if (len > ft_strlen(s))
-				ptr[j] = ft_strdup(&s[i]);
-			check_alloc(ptr, j);
+			word_len = ft_get_word_len(&str[i], c);
+			split[j] = malloc(sizeof(char) * (word_len + 1));
+			if (!split[j])
+				return (ft_clean_memory_exit(&split, i));
+			ft_strlcpy(split[j], &str[i], word_len + 1);
+			i += word_len;
 			j++;
 		}
-		i++;
+		else
+			i++;
 	}
-	ptr[j] = NULL;
-	return (ptr);
+	split[j] = NULL;
+	return (1);
 }
 
-char	**ft_split(char const *s, char c)
+char	**ft_split(char const *str, char c)
 {
-	size_t	word;
-	char	**ptr;
+	size_t	size_arr_word;
+	char	**arr_str;
 
-	word = 0;
-	if (!s)
+	size_arr_word = 0;
+	if (!str)
 		return (NULL);
-	word = count_word(s, c);
-	ptr = malloc((sizeof(char *) * (word + 1)));
-	if (!ptr)
-	{
-		free(ptr);
+	size_arr_word = ft_count_word(str, c);
+	if ((int)size_arr_word == -1)
 		return (NULL);
+	arr_str = malloc((sizeof(char *) * (size_arr_word + 1)));
+	if (!arr_str)
+		return (NULL);
+	if (!ft_process_data(arr_str, str, c))
+	{
+		free(arr_str);
+		arr_str = NULL;
 	}
-	process_data(ptr, s, c, word);
-	return (ptr);
+	return (arr_str);
 }
diff --git a/libft/ft_split.o b/libft/ft_split.o
new file mode 100644
index 0000000..e697518
Binary files /dev/null and b/libft/ft_split.o differ
diff --git a/libft/ft_split_clean.o b/libft/ft_split_clean.o
new file mode 100644
index 0000000..dcc331c
Binary files /dev/null and b/libft/ft_split_clean.o differ
diff --git a/libft/ft_split_is_sort.c b/libft/ft_split_is_sort.c
new file mode 100644
index 0000000..dd36444
--- /dev/null
+++ b/libft/ft_split_is_sort.c
@@ -0,0 +1,32 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_split_is_sort.c                                 :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/04/02 17:07:41 by cw3l              #+#    #+#             */
+/*   Updated: 2025/04/02 17:09:02 by cw3l             ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+int ft_is_split_sort(char **split)
+{
+    int i;
+    int j;
+    int split_len;
+
+    i = 0;
+    split_len = ft_get_split_len(split);
+    while (i < split_len - 1)
+    {
+        j = i + 1;
+        if(ft_strncmp(split[i], split[j], ft_strlen(split[i])) > 0)
+            return(0);
+        i++;
+    }
+    return(1);
+    
+}
diff --git a/libft/ft_split_is_sort.o b/libft/ft_split_is_sort.o
new file mode 100644
index 0000000..e32c0aa
Binary files /dev/null and b/libft/ft_split_is_sort.o differ
diff --git a/libft/ft_split_len.c b/libft/ft_split_len.c
index f8b09de..fd9a40f 100644
--- a/libft/ft_split_len.c
+++ b/libft/ft_split_len.c
@@ -18,6 +18,9 @@ size_t	ft_get_split_len(char **split)
 
 	i = 0;
 	while (*split)
+	{
 		i++;
+		split++;
+	}
 	return (i);
 }
diff --git a/libft/ft_split_len.o b/libft/ft_split_len.o
new file mode 100644
index 0000000..1036899
Binary files /dev/null and b/libft/ft_split_len.o differ
diff --git a/libft/ft_split_print.c b/libft/ft_split_print.c
new file mode 100644
index 0000000..16001de
--- /dev/null
+++ b/libft/ft_split_print.c
@@ -0,0 +1,23 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_split_print.c                                   :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/28 14:16:19 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/28 14:23:39 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+void	ft_split_print(char **split)
+{
+	while (*split)
+	{
+		write(1, *split, ft_strlen(*split));
+		write(1, "\n", 1);
+		split++;
+	}
+}
diff --git a/libft/ft_split_print.o b/libft/ft_split_print.o
new file mode 100644
index 0000000..84948bc
Binary files /dev/null and b/libft/ft_split_print.o differ
diff --git a/libft/ft_split_quick_sort.c b/libft/ft_split_quick_sort.c
new file mode 100644
index 0000000..426afa8
--- /dev/null
+++ b/libft/ft_split_quick_sort.c
@@ -0,0 +1,46 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_split_quick_sort.c                              :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/04/02 17:07:08 by cw3l              #+#    #+#             */
+/*   Updated: 2025/04/04 12:03:03 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "libft.h"
+
+static int ft_split_partition(char **split, int end, int (*cmp)(const char *,const char *, size_t len))
+{
+    int i;
+    int j;
+    char *pivot;
+    
+    i = 0;
+    j = end - 1;
+    pivot = split[end / 2];
+    while (i < j)
+    {
+        while (cmp(split[i], pivot, ft_strlen(split[i])) < 0)
+            i++;
+        while (cmp(split[j], pivot, ft_strlen(split[j])) > 0)
+            j--;
+        if(cmp(split[i], split[j], ft_strlen(split[i])) > 0)
+            ft_swap_str(&split[i], &split[j]);
+    }
+    return(i);
+}
+
+void    ft_env_quick_sortft_split_quick_sort(char **split, int end, int (*cmp)(const char *,const char *, size_t len))
+{
+    int i;
+
+    if(end <= 1)
+        return ;
+    i = ft_split_partition(split,end,cmp);
+    ft_split_quick_sort(split,i,cmp);
+    ft_split_quick_sort(&split[i + 1], end - 1 - i , cmp);
+
+}
\ No newline at end of file
diff --git a/libft/ft_split_quick_sort.o b/libft/ft_split_quick_sort.o
new file mode 100644
index 0000000..040c746
Binary files /dev/null and b/libft/ft_split_quick_sort.o differ
diff --git a/libft/ft_strchr.o b/libft/ft_strchr.o
new file mode 100644
index 0000000..3cd0739
Binary files /dev/null and b/libft/ft_strchr.o differ
diff --git a/libft/ft_strdup.o b/libft/ft_strdup.o
new file mode 100644
index 0000000..f59f9a4
Binary files /dev/null and b/libft/ft_strdup.o differ
diff --git a/libft/ft_striteri.o b/libft/ft_striteri.o
new file mode 100644
index 0000000..c106182
Binary files /dev/null and b/libft/ft_striteri.o differ
diff --git a/libft/ft_strjoin.o b/libft/ft_strjoin.o
new file mode 100644
index 0000000..a6a36c8
Binary files /dev/null and b/libft/ft_strjoin.o differ
diff --git a/libft/ft_strlcat.o b/libft/ft_strlcat.o
new file mode 100644
index 0000000..6f1c7c4
Binary files /dev/null and b/libft/ft_strlcat.o differ
diff --git a/libft/ft_strlcpy.o b/libft/ft_strlcpy.o
new file mode 100644
index 0000000..6c8b50c
Binary files /dev/null and b/libft/ft_strlcpy.o differ
diff --git a/libft/ft_strlen.o b/libft/ft_strlen.o
new file mode 100644
index 0000000..74a5f1a
Binary files /dev/null and b/libft/ft_strlen.o differ
diff --git a/libft/ft_strmapi.o b/libft/ft_strmapi.o
new file mode 100644
index 0000000..3afdc61
Binary files /dev/null and b/libft/ft_strmapi.o differ
diff --git a/libft/ft_strncmp.o b/libft/ft_strncmp.o
new file mode 100644
index 0000000..0495694
Binary files /dev/null and b/libft/ft_strncmp.o differ
diff --git a/libft/ft_strnstr.o b/libft/ft_strnstr.o
new file mode 100644
index 0000000..8ee1a31
Binary files /dev/null and b/libft/ft_strnstr.o differ
diff --git a/libft/ft_strrchr.o b/libft/ft_strrchr.o
new file mode 100644
index 0000000..da30f75
Binary files /dev/null and b/libft/ft_strrchr.o differ
diff --git a/libft/ft_strtrim.o b/libft/ft_strtrim.o
new file mode 100644
index 0000000..eb4afa1
Binary files /dev/null and b/libft/ft_strtrim.o differ
diff --git a/libft/ft_substr.o b/libft/ft_substr.o
new file mode 100644
index 0000000..114b32d
Binary files /dev/null and b/libft/ft_substr.o differ
diff --git a/libft/ft_swap_ptr.o b/libft/ft_swap_ptr.o
new file mode 100644
index 0000000..1d7fb71
Binary files /dev/null and b/libft/ft_swap_ptr.o differ
diff --git a/libft/ft_swap_str.c b/libft/ft_swap_str.c
new file mode 100644
index 0000000..6a13cef
--- /dev/null
+++ b/libft/ft_swap_str.c
@@ -0,0 +1,23 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_swap_str.c                                      :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/04/04 12:00:46 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/04 12:02:40 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+void ft_swap_str(char **str_1, char **str_2)
+{
+    char *tmp;
+
+    if(*str_1 && *str_2)
+    {
+        tmp = *str_1;
+        *str_1 = *str_2;
+        *str_2 = tmp;
+    }
+}
\ No newline at end of file
diff --git a/libft/ft_swap_str.o b/libft/ft_swap_str.o
new file mode 100644
index 0000000..cf9d006
Binary files /dev/null and b/libft/ft_swap_str.o differ
diff --git a/libft/ft_tolower.o b/libft/ft_tolower.o
new file mode 100644
index 0000000..c8e97a8
Binary files /dev/null and b/libft/ft_tolower.o differ
diff --git a/libft/ft_toupper.o b/libft/ft_toupper.o
new file mode 100644
index 0000000..fd137ad
Binary files /dev/null and b/libft/ft_toupper.o differ
diff --git a/libft/libft.a b/libft/libft.a
index f6243b9..2778d1a 100644
Binary files a/libft/libft.a and b/libft/libft.a differ
diff --git a/libft/libft.h b/libft/libft.h
index 9e2407e..c3ab97d 100644
--- a/libft/libft.h
+++ b/libft/libft.h
@@ -3,10 +3,10 @@
 /*                                                        :::      ::::::::   */
 /*   libft.h                                            :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2024/10/01 10:34:03 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/24 21:19:09 by cw3l             ###   ########.fr       */
+/*   Updated: 2025/04/04 12:08:14 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -56,6 +56,7 @@ void	ft_putnbr_fd(int n, int fd);
 char	**ft_split(char const *s, char c);
 size_t 	ft_get_split_len(char **split);
 void	*ft_split_clean(char ***split);
+void	ft_split_print(char **split);
 
 typedef struct s_list
 {
@@ -91,5 +92,9 @@ void	ft_print_bit_64(int n);
 int		ft_index_of(int *arr, int len, int n);
 void 	ft_generate_number(int *arr, int size);
 int		ft_get_max_value(int *arr, int size);
+void    ft_split_quick_sort(char **split, int end, int (*cmp)(const char *,const char *, size_t len));
+int 	ft_is_split_sort(char **split);
+void	ft_swap_str(char **str_1, char **str_2);
+int 	ft_is_split_sort(char **split);
 
 #endif
\ No newline at end of file
diff --git a/minishell b/minishell
index 87156b4..65eecc2 100755
Binary files a/minishell and b/minishell differ
diff --git a/srcs/builtin/builtin.h b/srcs/builtin/builtin.h
new file mode 100644
index 0000000..87965b0
--- /dev/null
+++ b/srcs/builtin/builtin.h
@@ -0,0 +1,38 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   builtin.h                                          :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 11:02:58 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/04 11:54:36 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#ifndef BUILTIN_H
+# define BUILTIN_H
+
+# include <unistd.h>
+# include <stdlib.h>
+# include <stdio.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <unistd.h>
+# include "../../include/main.h"
+
+void	ft_pwd(void);
+void	ft_echo(char *str, int fd, int option);
+int		ft_cd(char *path);
+int     ft_exit(int ret);
+
+
+// Export fonction
+
+int     ft_export(char ***env, char ***var);
+int     ft_count_valide_variable(char **var);
+char    **ft_add_variable(char **old_env, char **new_var);
+int     ft_check_variable(char *var);
+void    ft_display_variables_list(char *envp[]);
+int     ft_idx_of(char *str, char c);
+#endif
\ No newline at end of file
diff --git a/srcs/builtin/cd.c b/srcs/builtin/cd.c
new file mode 100644
index 0000000..ecf8b92
--- /dev/null
+++ b/srcs/builtin/cd.c
@@ -0,0 +1,56 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   cd.c                                               :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 12:30:49 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/26 16:48:28 by cw3l             ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "builtin.h"
+
+char	*ft_get_home_path(char *path)
+{
+	char	*env;
+	char	*total_path;
+
+	env = getenv("HOME");
+	if (!env)
+		return (NULL);
+	total_path = ft_strjoin(env, &path[1]);
+	if (!total_path)
+		return (NULL);
+	path = total_path;
+	return (total_path);
+}
+
+int	ft_cd(char *path)
+{
+	int		chdir_return;
+	char	*total_path;
+	
+	total_path = NULL;
+	if (path[0] == '~')
+	{
+		total_path = ft_get_home_path(path);
+		if (!total_path)
+			return (-1);
+		
+	}
+	if(total_path)
+	{
+		chdir_return = chdir(total_path);
+		free(total_path);
+	}
+	else
+		chdir_return = chdir(path);
+	if (chdir_return == -1)
+	{
+		printf("cd: no such file or directory: %s\n", path);
+		return (-1);
+	}
+	return (1);
+}
diff --git a/srcs/builtin/echo.c b/srcs/builtin/echo.c
new file mode 100644
index 0000000..9fdcf0d
--- /dev/null
+++ b/srcs/builtin/echo.c
@@ -0,0 +1,27 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   echo.c                                             :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 12:29:53 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/26 14:50:09 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "builtin.h"
+
+void	ft_echo(char *str, int fd, int option)
+{
+	int	i;
+
+	i = 0;
+	while (str[i])
+	{
+		write(fd, &str[i], 1);
+		i++;
+	}
+	if (option == 0)
+		write(fd, "\n", 2);
+}
diff --git a/srcs/builtin/env.c b/srcs/builtin/env.c
new file mode 100644
index 0000000..ba8f1c2
--- /dev/null
+++ b/srcs/builtin/env.c
@@ -0,0 +1,18 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   echo.c                                             :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 12:29:53 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/26 14:50:09 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+// int ft_env(char ***envp)
+// {
+//     char **env;
+
+//     env = envp;
+// }
\ No newline at end of file
diff --git a/srcs/builtin/export.c b/srcs/builtin/export.c
new file mode 100644
index 0000000..876f49a
--- /dev/null
+++ b/srcs/builtin/export.c
@@ -0,0 +1,172 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   export.c                                           :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 10:52:29 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/04 13:37:18 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "builtin.h"
+
+
+//error message;
+//bash: export: « 2x » : identifiant non valable
+
+
+void ft_display_variables_list(char *envp[])
+{
+    while (*envp)
+    {
+        printf("%s\n", *envp);
+        envp++;
+    }
+    
+}
+
+int ft_check_variable(char *var)
+{
+    int i;
+
+    if(!var)
+        return(0);
+    i = 0;
+
+    // first check if the first char are alpha.
+    while (ft_isalpha(var[i]))
+        i++;
+
+    //  if i = 0 the first char are not alpha so the variable is incorect. 
+    if(i == 0)
+        return(0);
+    
+    // after that,only alnum are valide.
+    while (var[i])
+    {
+        if(!ft_isalnum(var[i]) && var[i] != '=')
+            return(0);
+        i++;
+    }
+    return(1);
+}
+
+int ft_idx_of(char *str, char c)
+{
+    int i;
+
+    i = 0;
+
+    while (str[i] != '\0')
+    {
+        if(str[i] == c)
+            return(i);
+        i++;
+    }
+    return(-1);
+}
+/* fonction who check if de variable is arlready in env  before copying it */
+static int ft_is_on_env(char **env, char *var, int size)
+{
+    int i;
+
+    i = 0;
+    while (i < size)
+    {
+
+        int idx = ft_idx_of(env[i], '=');
+        if(ft_str_env_cmp(env[i], var, idx) == 0)
+        {
+            printf("nous najouterons pas %s comparer avec %s\n",var,  env[i]);
+            return(1);
+        }
+        i++;
+    }
+    return(0);
+}
+
+
+char **ft_add_variable(char **old_env, char **new_var)
+{    
+    size_t i;
+    size_t j;
+    char **new_env;
+    int env_len;
+
+    env_len = ft_get_split_len(old_env) + ft_get_split_len(new_var);
+    new_env = malloc(sizeof(char *) * (env_len + 1));
+    if(!new_env)
+        return(NULL);
+    i = 0;
+    j = 0;
+    while (i < ft_get_split_len(old_env))
+        new_env[j++] = old_env[i++];
+    i = 0;
+    while (i < ft_get_split_len(new_var))
+    {
+        // check if the new variable is already in env.
+        if(!ft_is_on_env(new_env, new_var[i],j))
+            new_env[j++] = new_var[i];
+        else
+        {
+            //if the variable is already in env, dont forget to free the unused variable.
+            free(new_var[i]);
+        }
+        i++;
+    }
+    new_env[j] = NULL;
+    return(new_env);
+}
+
+
+int ft_count_valide_variable(char **var)
+{
+    int i;
+
+    i = 0;
+    if(!var)
+        return(0);
+    while (*var)
+    {
+        if(ft_check_variable(*var))
+            i++;
+        var++;
+    }
+    return(i);
+}
+
+int ft_export(char ***env, char ***var)
+{
+    char **new_env;
+    int valide_variable_len;
+
+    if(!(*env))
+        return(-1);
+    if(!var || ft_strncmp(*(*var),"", 1) == 0)
+    {
+        /*  if no variable shell display the list of variable env */
+        ft_display_variables_list(*env);
+        return(1);
+    }
+    else
+    {
+        /* else add the variable to the variable list but before,
+        we need to check and count the good variable format  for the new allocation*/
+        valide_variable_len = ft_count_valide_variable(*var);
+        if(valide_variable_len)
+        {
+            new_env = ft_add_variable(*env, *var);
+            if(!env)
+                return(0);
+            free(*env);
+            free(*var);
+            *env = new_env;
+            env_quick_s(new_env,ft_get_split_len(new_env),ft_str_env_cmp);
+            //ft_sort_env(*env);
+        }
+    }
+    return(1);
+}
+
diff --git a/srcs/builtin/ft_exit.c b/srcs/builtin/ft_exit.c
new file mode 100644
index 0000000..d38b8ac
--- /dev/null
+++ b/srcs/builtin/ft_exit.c
@@ -0,0 +1,35 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   ft_exit.c                                          :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 10:52:29 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/28 13:58:09 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "builtin.h"
+
+
+int ft_exit(int ret)
+{
+    int pid;
+    int p;
+
+    pid = fork();
+    if(pid == 0)
+    {
+
+        printf("voici i child %d\n", pid);
+    }
+    else
+    {
+        
+        printf("voici i parent %d\n", pid);
+    }
+    waitpid(pid, &p,0);
+    printf("voici la vqleur de reotur %d et %d\n", p, pid);
+    return(ret);
+}
\ No newline at end of file
diff --git a/srcs/builtin/pwd.c b/srcs/builtin/pwd.c
new file mode 100644
index 0000000..ee0e2ff
--- /dev/null
+++ b/srcs/builtin/pwd.c
@@ -0,0 +1,37 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   pwd.c                                              :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 11:06:30 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/07 12:14:35 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "builtin.h"
+
+void	ft_pwd(void)
+{
+	TEST_START;
+	int		i;
+	char	path[1024];
+
+	if (!getcwd(path, sizeof(path)))
+	{
+		printf("error get path %p\n", path);
+		return ;
+	}
+	i = 0;
+	while (path[i])
+	{
+		write(1, &path[i], 1);
+		i++;
+	}
+	write(1, "\n", 1);
+	TEST_SUCCES;
+}
+
+/* Check for change sizeof buffer*/
+// maybe change this error output.
\ No newline at end of file
diff --git a/srcs/exec/exec.c b/srcs/exec/exec.c
deleted file mode 100644
index e10ea4e..0000000
--- a/srcs/exec/exec.c
+++ /dev/null
@@ -1,253 +0,0 @@
-#include "exec.h"
-
-static void execute_command(const char *command)
-{
-    pid_t pid = fork();
-    if (pid == -1)
-    {
-        perror("fork");
-        return;
-    }
-    if (pid == 0)
-    {
-        char *args[] = {"/bin/sh", "-c", (char *)command, NULL};
-        execvp(args[0], args);
-        perror("execvp");
-        exit(EXIT_FAILURE);
-    }
-    waitpid(pid, NULL, 0);
-}
-
-static void execute_with_redirection(t_token *node, int flags)
-{
-    if (!node->left || !node->right)
-    {
-        fprintf(stderr, "Invalid AST structure for redirection.\n");
-        return;
-    }
-
-    pid_t pid = fork();
-    if (pid == -1)
-    {
-        perror("fork");
-        return;
-    }
-
-    if (pid == 0)
-    {
-        int fd = open(node->right->string, flags, 0644);
-        if (fd == -1)
-        {
-            perror("open");
-            exit(EXIT_FAILURE);
-        }
-
-        if (dup2(fd, STDOUT_FILENO) == -1)
-        {
-            perror("dup2");
-            close(fd);
-            exit(EXIT_FAILURE);
-        }
-        close(fd);
-
-        execute_ast(node->left);
-        exit(EXIT_SUCCESS);
-    }
-    waitpid(pid, NULL, 0);
-}
-
-// 입력 리다이렉션 처리 (<)
-void redirect_input_and_execute(t_token *node)
-{
-    if (!node->left || !node->right)
-    {
-        fprintf(stderr, "Input redirection error: Missing left/right node.\n");
-        return;
-    }
-
-    int fd = open(node->right->string, O_RDONLY);
-    if (fd == -1)
-    {
-        perror("open (input redirection)");
-        return;
-    }
-
-    pid_t pid = fork();
-    if (pid == 0)
-    {
-        if (dup2(fd, STDIN_FILENO) == -1)
-        {
-            perror("dup2 (input redirection)");
-            close(fd);
-            exit(EXIT_FAILURE);
-        }
-        close(fd);
-        execute_ast(node->left); // 입력 리다이렉션 후 왼쪽 명령 실행
-        exit(EXIT_SUCCESS);
-    }
-    else if (pid > 0)
-    {
-        close(fd);
-        waitpid(pid, NULL, 0);
-    }
-    else
-        perror("fork (input redirection)");
-}
-
-
-static void execute_pipe(t_token *node)
-{
-    int pipefd[2];
-    if (pipe(pipefd) == -1)
-    {
-        perror("pipe");
-        return;
-    }
-
-    pid_t left_pid = fork();
-    if (left_pid == 0)
-    {
-        close(pipefd[0]);
-        dup2(pipefd[1], STDOUT_FILENO);
-        close(pipefd[1]);
-
-        execute_ast(node->left);
-        exit(EXIT_SUCCESS);
-    }
-
-    pid_t right_pid = fork();
-    if (right_pid == 0)
-    {
-        close(pipefd[1]);
-        dup2(pipefd[0], STDIN_FILENO);
-        close(pipefd[0]);
-
-        execute_ast(node->right);
-        exit(EXIT_SUCCESS);
-    }
-
-    close(pipefd[0]);
-    close(pipefd[1]);
-
-    waitpid(left_pid, NULL, 0);
-    waitpid(right_pid, NULL, 0);
-}
-
-void heredoc_redirect(t_token *node)
-{
-    if (!node || !node->right)
-    {
-        fprintf(stderr, "Heredoc error: Missing delimiter or command.\n");
-        return;
-    }
-
-    char *delimiter = node->right->string;
-    int pipefd[2];
-
-    if (pipe(pipefd) == -1)
-    {
-        perror("pipe");
-        return;
-    }
-
-    pid_t pid = fork();
-    if (pid == -1)
-    {
-        perror("fork");
-        return;
-    }
-    else if (pid == 0) // Child process for heredoc reading
-    {
-        close(pipefd[0]); // Close the read end, we're only writing
-
-        char *line;
-        while (1)
-        {
-            //line = readline("> ");
-			line = readline("heredoc> ");
-            if (!line || strcmp(line, delimiter) == 0) // Stop when delimiter is found
-            {
-                free(line);
-                break;
-            }
-            write(pipefd[1], line, strlen(line));
-            write(pipefd[1], "\n", 1); // Add newline to each line
-            free(line);
-        }
-
-        close(pipefd[1]); // Close the write end
-        exit(0); // End the child process
-    }
-    else // Parent process
-    {
-        close(pipefd[1]); // Close write end, we're only reading
-        waitpid(pid, NULL, 0);
-
-        // Redirect stdin to read from the pipe
-        if (dup2(pipefd[0], STDIN_FILENO) == -1)
-        {
-            perror("dup2 failed");
-            close(pipefd[0]);
-            return;
-        }
-        close(pipefd[0]);
-    }
-}
-
-
-void execute_ast(t_token *node)
-{
-    if (!node)
-        return;
-
-    switch (node->token)
-    {
-        case 1: // CMD
-            execute_command(node->string);
-            break;
-
-        case 4: // PIPE
-            execute_pipe(node);
-            break;
-
-		case 5: // INPUT REDIRECTION (<)
-			redirect_input_and_execute(node);
-			break;
-
-        case 6: // >
-            execute_with_redirection(node, O_WRONLY | O_CREAT | O_TRUNC);
-            break;
-
-        case 7: // >>
-            execute_with_redirection(node, O_WRONLY | O_CREAT | O_APPEND);
-            break;
-
-		case 10: // HEREDOC (<<) //added new codes for fixing unexpected crash after heredoc
-        {
-            int original_stdin = dup(STDIN_FILENO); // Save the original stdin
-            if (original_stdin == -1)
-            {
-                perror("dup failed");
-                return;
-            }
-            heredoc_redirect(node);
-            execute_ast(node->left); // Execute the command with redirected input
-            if (dup2(original_stdin, STDIN_FILENO) == -1) // Restore original stdin
-            {
-                perror("dup2 failed to restore stdin");
-            }
-            close(original_stdin);
-            break;
-        }
-		/*
-		case 10: // HEREDOC (<<)
-            heredoc_redirect(node);
-            execute_ast(node->left); // Execute the command after setting up heredoc. why? 
-            break;
-		*/
-        default:
-            fprintf(stderr, "Unknown token type: %d\n", node->token);
-            break;
-    }
-}
-
diff --git a/srcs/exec/exec.h b/srcs/exec/exec.h
deleted file mode 100644
index 590b83d..0000000
--- a/srcs/exec/exec.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef EXEC_H
-#define EXEC_H
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <fcntl.h>
-
-typedef struct s_token t_token;
-
-#include "../parser/tokenizer/tokenize.h"
-
-void	execute_ast(t_token *node);
-
-#endif
\ No newline at end of file
diff --git a/srcs/execution/env_quick_sort.c b/srcs/execution/env_quick_sort.c
new file mode 100644
index 0000000..46b7e2c
--- /dev/null
+++ b/srcs/execution/env_quick_sort.c
@@ -0,0 +1,100 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   env_quick_sort.c                                   :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/04/02 17:07:08 by cw3l              #+#    #+#             */
+/*   Updated: 2025/04/04 15:10:29 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "execution.h"
+
+static char	*ft_extract_var(char *str)
+{
+	int		idx;
+	char	*new_var;
+
+	idx = ft_idx_of(str, '=');
+	if (idx == -1)
+		return (str);
+	new_var = ft_strdup(str);
+	new_var[idx] = '\0';
+	return (new_var);
+}
+
+int	str_env_cmp_process(char *s1, char *s2, size_t n)
+{
+	size_t	i;
+	char	*trimed_s1;
+	char	*trimed_s2;
+	i = 0;
+
+	trimed_s1 = ft_extract_var(s1);
+	trimed_s2 = ft_extract_var(s2);
+	while ((trimed_s1[i] || trimed_s2[i]) && i < n)
+	{
+		if ((unsigned char)trimed_s1[i] != (unsigned char)trimed_s2[i])
+		{
+			if ((unsigned char)trimed_s1[i] > (unsigned char)trimed_s2[i])
+				return (1);
+			if ((unsigned char)trimed_s1[i] < (unsigned char)trimed_s2[i])
+				return (-1);
+		}
+		i++;
+	}
+	free(trimed_s1);
+	free(trimed_s2);
+	return (0);
+}
+
+int	ft_str_env_cmp(char *s1, char *s2, size_t n)
+{
+	int		process_r;
+	int		len;
+
+	if (n == 0)
+		return (0);	
+	if (ft_strlen(s1) >= ft_strlen(s2))
+		len = ft_strlen(s1);
+	else
+		len = ft_strlen(s2);
+	process_r = str_env_cmp_process(s1, s2, len);
+	if (process_r != 0)
+		return (process_r);
+	return (0);
+}
+
+int	ft_split_part(char **s, int end, int (*cmp)(char *, char *, size_t len))
+{
+	int		i;
+	int		j;
+	char	*pivot;
+
+	i = 0;
+	j = end - 1;
+	pivot = s[end / 2];
+	while (i < j)
+	{
+		while (cmp(s[i], pivot, ft_strlen(s[i])) < 0)
+			i++;
+		while (cmp(s[j], pivot, ft_strlen(s[j])) > 0)
+			j--;
+		if (cmp(s[i], s[j], ft_strlen(s[i])) > 0)
+			ft_swap_str(&s[i], &s[j]);
+	}
+	return (i);
+}
+
+void	env_quick_s(char **s, int end, int (*cmp)(char *, char *, size_t len))
+{
+	int	i;
+
+	if (end <= 1)
+		return ;
+	i = ft_split_part(s, end, cmp);
+	env_quick_s(s, i, cmp);
+	env_quick_s(&s[i + 1], end - 1 - i, cmp);
+}
diff --git a/srcs/execution/environnement.c b/srcs/execution/environnement.c
new file mode 100644
index 0000000..1d74f49
--- /dev/null
+++ b/srcs/execution/environnement.c
@@ -0,0 +1,89 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   environnement.c                                    :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 10:52:29 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/04 13:23:08 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "execution.h"
+
+int ft_is_env_sort(char **split)
+{
+    int i;
+    int j;
+    int split_len;
+
+    i = 0;
+    split_len = ft_get_split_len(split);
+    while (i < split_len - 1)
+    {
+        j = i + 1;
+        if(ft_str_env_cmp(split[i], split[j], ft_strlen(split[i])) > 0)
+            return(0);
+        i++;
+    }
+    return(1);
+    
+}
+
+void    ft_display_env(char **env)
+{
+    if(env)
+    {
+        while (*env)
+        {
+            printf("%s\n", *env);
+            env++;
+        }
+    }
+}
+
+void *ft_destroy_env(char **envp[], int idx)
+{
+    int i;
+    char **env;
+
+    env = *envp;
+    i = 0;
+    while (i < idx)
+    {
+        free(*env);
+        *env = NULL;
+        i++;
+    }
+    return (NULL);
+}
+
+
+char **ft_duplicate_env(char *envp[])
+{
+    int env_len;
+    char **dup_env;
+    char *tmp;
+    int i;
+
+    if(!envp)
+        return(NULL);
+    env_len = ft_get_split_len(envp);
+    dup_env = malloc(sizeof(char *) * (env_len + 1));
+    if(!dup_env)
+        return(NULL);
+    i = 0;
+    while (envp[i])
+    {
+        tmp = ft_strdup(envp[i]);
+        if(!tmp)
+            return(ft_destroy_env(&dup_env, i));
+        dup_env[i] = tmp;
+        i++;
+    }
+    dup_env[i] = NULL;
+    /* bubble sort fonction ft_sort_env(dup_env); */
+    env_quick_s(dup_env, env_len,ft_str_env_cmp);
+    return(dup_env);
+}
diff --git a/srcs/execution/exe_cmd.c b/srcs/execution/exe_cmd.c
new file mode 100644
index 0000000..12256b0
--- /dev/null
+++ b/srcs/execution/exe_cmd.c
@@ -0,0 +1,53 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   exe_cmd.c                                          :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 12:30:49 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/28 19:05:47 by cw3l             ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "execution.h"
+
+int ft_cmd_launcher(t_token *token_lst)
+{
+    TEST_START;
+
+    int  fds[2];
+    int childen_count;
+    int status;
+
+    pid_t pid;
+    pid_t res;
+    
+    char *arg[] = {"clear", NULL, NULL};
+    childen_count = ft_count_occurence_of_token(token_lst, PIPE);
+    (void)childen_count;
+    pipe(fds); 
+    pid = fork();
+    if(pid == 0)
+    {
+        close(fds[1]);
+        close(fds[0]);
+        printf("start commande\n");
+        if(execve("/usr/bin/clear",arg,NULL) == -1)
+        {
+            printf("Error\n");
+            return(-1);
+        }
+    }
+    else
+    {
+        // close(fds[1]);
+        // close(fds[0]);
+        res = waitpid(pid,&status,0);
+        assert(res);
+        return(0);
+        //printf("voici le resultat %d\n",  waitpid(pid,&status,0));
+    }
+   TEST_SUCCES;
+    return(1);
+}
\ No newline at end of file
diff --git a/srcs/execution/execution.h b/srcs/execution/execution.h
new file mode 100644
index 0000000..76328f4
--- /dev/null
+++ b/srcs/execution/execution.h
@@ -0,0 +1,40 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   execution.h                                        :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 12:30:49 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/04 13:43:44 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#ifndef EXECUTION_H
+#define EXECUTION_H
+
+# include <unistd.h>
+# include <stdlib.h>
+# include <stdio.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <termios.h>
+
+#include "../parser/parser.h"
+#include "../parser/tokenizer/tokenize.h"
+
+//int     ft_cmd_launcher(t_token *token);
+void    ft_set_signal(void);
+
+// environements
+
+char    **ft_duplicate_env(char *envp[]);
+int     ft_get_env_len(char *envp[]);
+void    *ft_destroy_env(char **envp[], int idx);
+void    ft_display_env(char **env);
+void	env_quick_s(char **s, int end, int (*cmp)(char *, char *, size_t len)); //quick sort fonction for env.
+int	    ft_str_env_cmp(char *s1, char *s2, size_t n);
+int     ft_is_env_sort(char **split);
+
+#endif
\ No newline at end of file
diff --git a/srcs/subsystems/subsystems.c b/srcs/execution/interface.c
similarity index 78%
rename from srcs/subsystems/subsystems.c
rename to srcs/execution/interface.c
index ac0ba7b..5d61a40 100644
--- a/srcs/subsystems/subsystems.c
+++ b/srcs/execution/interface.c
@@ -1,12 +1,11 @@
 /* ************************************************************************** */
 /*                                                                            */
 /*                                                        :::      ::::::::   */
-/*   subsystems.c                                       :+:      :+:    :+:   */
+/*   tst_main.c                                         :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
 /*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/03/17 10:29:16 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/17 10:29:19 by cbouhadr         ###   ########.fr       */
+/*   Created: 2025/03/17 13:17:01 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/28 16:35:53 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
-
diff --git a/srcs/execution/signal.c b/srcs/execution/signal.c
new file mode 100644
index 0000000..fab3781
--- /dev/null
+++ b/srcs/execution/signal.c
@@ -0,0 +1,33 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   tst_main.c                                         :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/17 13:17:01 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/28 16:35:53 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "execution.h"
+
+
+void    ft_print_message(int signal)
+{
+    printf("message reçu %d\n", signal);
+}
+
+
+
+void ft_set_signal(void)
+{
+    struct sigaction sa;
+
+    sa.sa_handler = ft_print_message;
+    ft_bzero(&sa, sizeof(sa));
+    
+    if(sigaction(SIGINT,&sa,NULL) != 0)
+        perror("Err init sigaction");
+    
+}
\ No newline at end of file
diff --git a/srcs/main.c b/srcs/main.c
index f014610..fa8dbcb 100644
--- a/srcs/main.c
+++ b/srcs/main.c
@@ -5,19 +5,24 @@
 /*                                                    +:+ +:+         +:+     */
 /*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/03/13 22:15:03 by cw3l              #+#    #+#             */
-/*   Updated: 2025/04/07 14:03:03 by cbouhadr         ###   ########.fr       */
+/*   Created: Invalid date        by                   #+#    #+#             */
+/*   Updated: 2025/04/07 14:29:38 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
- #include "../include/main.h"
 
+ #include "../include/main.h"
 
- int main(void)//int argc char **argv, char **env
- {
- 	ft_start_minishell("minishell: ");
- 	return(0);
- }
- 
 
+int main(int argc, char **argv, char *envp[])
+{
 
+    (void)argc;
+    (void)argv;
+    (void)envp;
+    //ft_pwd();
+    printf("voici start mini\n");
+    ft_start_minishell("Mini-shell $ ");
+    
+    return(0);
+}
\ No newline at end of file
diff --git a/srcs/parser/lexer/ast_parser/ast.h b/srcs/parser/lexer/ast_parser/ast.h
deleted file mode 100644
index 8cd2b02..0000000
--- a/srcs/parser/lexer/ast_parser/ast.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast.h                                              :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/03/19 13:51:55 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/20 12:10:08 by cbouhadr         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#ifndef AST_H
-#define AST_H
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include "../../../../libft/libft.h"
-#include "../../../../include/main.h"
-
-
-#define  LEFT 0
-#define RIGHT 0
-
-typedef struct s_ast_node
-{
-    int c;
-    char *value;
-    struct s_ast_node *parent;
-    struct s_ast_node *right;
-    struct s_ast_node *left;
-
-} t_ast_node;
-
-t_ast_node      *ft_new_ast_node(char *str, int value);
-void            ft_ast_add_node(t_ast_node **start_node, t_ast_node *new_node);
-void            ft_ast_iter(t_ast_node *node, void (*f)(t_ast_node *));
-void            create_tree(t_ast_node *node,int start, int end, int idx);
-void            ft_count_node(t_ast_node *node, int *i);
-void            ft_print_ast_node_data(t_ast_node *node);
-void            ft_print_ast_tree(t_ast_node *racine);
-void            ft_print_ast_value(t_ast_node *node);
-
-#endif
\ No newline at end of file
diff --git a/srcs/parser/lexer/ast_parser/ast_display.c b/srcs/parser/lexer/ast_parser/ast_display.c
deleted file mode 100644
index 4d38bf2..0000000
--- a/srcs/parser/lexer/ast_parser/ast_display.c
+++ /dev/null
@@ -1,52 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast_display.c                                      :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/03/19 14:03:48 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/20 12:11:51 by cbouhadr         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "ast.h"
-
-void ft_print_ast_tree(t_ast_node *racine)
-{
-    if(racine)
-    {
-        ft_ast_iter(racine,ft_print_ast_node_data);
-    }
-}
-
-void ft_print_ast_node_data(t_ast_node *node)
-{
-    if(node)
-    {
-        printf("\n\n####################################\n\n");
-        printf("\tLabel : %s\n\n", node->value);
-        printf("Display du node numero:%c a l'adresse: %p\n", node->c, node);
-        if(!node->parent)
-            printf("Le noeud na pas de parent\n");
-        else
-            printf("Papa %p\n", node->parent);
-        if(!node->left)
-            printf("Le noeud na pas de fils gauche\n");
-        else
-            printf("fils gauche %p\n", node->left);
-        if(!node->right)
-            printf("Le noeud na pas de fils droit\n");
-        else
-            printf("fils droit %p\n", node->right);
-        printf("\n\n####################################\n\n");
-    }
-}
-
-void ft_print_ast_value(t_ast_node *node)
-{
-    if(node)
-    {
-        printf("%c ", node->c);
-    }
-}
\ No newline at end of file
diff --git a/srcs/parser/lexer/ast_parser/ast_instance.c b/srcs/parser/lexer/ast_parser/ast_instance.c
deleted file mode 100644
index f9c3c5a..0000000
--- a/srcs/parser/lexer/ast_parser/ast_instance.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast_instance.c                                     :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/03/17 19:56:51 by cw3l              #+#    #+#             */
-/*   Updated: 2025/03/20 10:02:08 by cbouhadr         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "ast.h"
-
-void create_tree(t_ast_node *node,int start, int end, int idx)
-{
-    t_ast_node *new_node;
-    
-    if(start > end)
-         return ;
-    if(!node->left)
-    {
-        new_node = ft_new_ast_node("hello", 'L');
-        node->left = new_node;
-        node->left->parent = node;
-        create_tree(node->left, start + 1, end, idx + 1);
-    }
-    if(!node->right)
-    {
-        new_node = ft_new_ast_node("hello", 'R');
-        node->right = new_node;
-        node->right->parent = node;
-        create_tree(node->right, start + 1, end, idx + 1);
-    }
-    
-}
-
-
-t_ast_node *ft_new_ast_node(char *str, int value)
-{
-    t_ast_node *new_node;
-
-    new_node = malloc(sizeof(t_ast_node));
-    if(!new_node)
-        return(NULL);
-    new_node->value = str;
-    new_node->c = value;
-    new_node->parent = NULL;
-    new_node->left = NULL;
-    new_node->right = NULL;
-
-    return(new_node);
-}
-
-
-
-
diff --git a/srcs/parser/lexer/ast_parser/ast_iter.c b/srcs/parser/lexer/ast_parser/ast_iter.c
deleted file mode 100644
index 8c88d89..0000000
--- a/srcs/parser/lexer/ast_parser/ast_iter.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast_iter.c                                         :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/03/19 14:15:47 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/20 12:30:26 by cbouhadr         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "ast.h"
-
-void ft_count_node(t_ast_node *node, int *i)
-{
-    if(!node || !i)
-        return ;
-    (*i)++;
-    ft_count_node(node->left, i);
-    ft_count_node(node->right, i);
-    return;
-}
-
-void ft_ast_add_node(t_ast_node **start_node, t_ast_node *new_node)
-{
-
-
-    if(!start_node)
-        return ;
-    if(!*start_node)
-        *start_node = new_node;
-    else
-    {
-        if(!(*start_node)->left)
-        {
-            (*start_node)->left = new_node;
-            (*start_node)->left->parent = *start_node;  
-        }
-        else if(!(*start_node)->right)
-        {
-            (*start_node)->right = new_node;
-            (*start_node)->right->parent = *start_node;
-        }
-        else
-        {
-            ft_ast_add_node(&(*start_node)->left, new_node);
-            ft_ast_add_node(&(*start_node)->right, new_node);
-        }
-        
-    }
-}
-
-// void    ft_clean_tree(t_ast_node *node)
-// {
-    
-// }
-
-void ft_ast_iter(t_ast_node *node, void (*f)(t_ast_node *))
-{
-    if(!node)
-        return ;
-    if(node)
-    {
-        
-        ft_ast_iter(node->left, f);
-        if(node->c == '<')
-            ft_ast_iter(node->right, f);
-        ft_ast_iter(node->right, f);
-
-        f(node);
-    }
-}
-
diff --git a/srcs/parser/lexer/precedence_climbing.h b/srcs/parser/lexer/precedence_climbing.h
index 04aa529..8cfecd9 100644
--- a/srcs/parser/lexer/precedence_climbing.h
+++ b/srcs/parser/lexer/precedence_climbing.h
@@ -6,7 +6,7 @@
 /*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/17 19:58:58 by cw3l              #+#    #+#             */
-/*   Updated: 2025/03/26 09:24:48 by cbouhadr         ###   ########.fr       */
+/*   Updated: 2025/03/26 10:04:39 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -21,7 +21,6 @@
 #include <stdio.h>
 #include "../../../libft/libft.h"
 #include "../../../include/main.h"
-#include "ast_parser/ast.h"
 
 void ft_climb_token(char *str, int precedence, int start, int end);
 char *ft_join(char *str, char c);
diff --git a/srcs/parser/lexer/precedence_climbing.o b/srcs/parser/lexer/precedence_climbing.o
deleted file mode 100644
index 7565003..0000000
Binary files a/srcs/parser/lexer/precedence_climbing.o and /dev/null differ
diff --git a/srcs/parser/parser.c b/srcs/parser/parser.c
index b490af9..b6b4e7d 100644
--- a/srcs/parser/parser.c
+++ b/srcs/parser/parser.c
@@ -3,10 +3,10 @@
 /*                                                        :::      ::::::::   */
 /*   parser.c                                           :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/17 10:32:32 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/25 11:59:24 by cw3l             ###   ########.fr       */
+/*   Updated: 2025/04/07 13:53:57 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
diff --git a/srcs/parser/parser.h b/srcs/parser/parser.h
index 4b1bc7d..b0afb7c 100644
--- a/srcs/parser/parser.h
+++ b/srcs/parser/parser.h
@@ -3,10 +3,10 @@
 /*                                                        :::      ::::::::   */
 /*   parser.h                                           :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/17 10:31:06 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/25 13:29:52 by cw3l             ###   ########.fr       */
+/*   Updated: 2025/03/28 15:55:25 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -32,16 +32,7 @@
 #include "tokenizer/tokenize.h"
 #include "../exec/exec.h"
 
-#define WORD 0
-#define CMD 1
-#define ARG 3
-#define PIPE 4
-#define REDIR_OPEN 5
-#define REDIR_WRITE 6
-#define REDIR_WRITE_A 7
-#define DOUBLE_REDIR 8
-#define HEREDOC 10
-#define VAR 11
+
 
 int     ft_start_minishell(char *str);
 int     ft_read_line(char *str);
diff --git a/srcs/parser/tokenizer/tokenize.c b/srcs/parser/tokenizer/tokenize.c
index 164aba1..6410a1a 100644
--- a/srcs/parser/tokenizer/tokenize.c
+++ b/srcs/parser/tokenizer/tokenize.c
@@ -3,10 +3,10 @@
 /*                                                        :::      ::::::::   */
 /*   tokenize.c                                         :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/24 20:36:54 by cw3l              #+#    #+#             */
-/*   Updated: 2025/03/25 15:49:51 by cw3l             ###   ########.fr       */
+/*   Updated: 2025/04/07 12:49:10 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -14,6 +14,7 @@
 
 void print_ast_simple(t_token *node, int indent) 
 {
+    TEST_START;
     if (node == NULL) 
 	{
         return;
@@ -41,10 +42,12 @@ void print_ast_simple(t_token *node, int indent)
          for (int i = 0; i < indent; i++) printf("  ");
          printf(" R-> NULL\n");
     }
+    TEST_SUCCES;
 }
 
 void print_ast(t_token *node, int depth)
 {
+    TEST_START;
     if (!node)
         return;
 
@@ -61,6 +64,7 @@ void print_ast(t_token *node, int depth)
     print_ast(node->left, depth + 1);   
     // Print right subtree after
     print_ast(node->right, depth + 1);
+    TEST_SUCCES;
 }
 
 int ft_delete_token_lst(t_token **token_lst)
@@ -78,7 +82,6 @@ int ft_delete_token_lst(t_token **token_lst)
             free(node->string);
             node->string = NULL;
         }
-		
         free(node);
         *token_lst = tmp;
     }
@@ -138,27 +141,6 @@ t_token *ft_tokenize(char *str)
     {
         token = ft_get_token(split[i]);  // Get token type
 
-		if (token == HEREDOC && split[i + 1]) // Handle HEREDOC
-        {
-            new_node = ft_new_token_node(split[i], token);
-            ft_add_back_node(&token_list, new_node);
-
-            // The delimiter is the next token
-            i++;
-            if (split[i])
-            {
-                t_token *delimiter_node = ft_new_token_node(split[i], 0); // Assuming 0 is a generic type for delimiter
-                ft_add_back_node(&token_list, delimiter_node);
-            }
-            else
-            {
-                fprintf(stderr, "Error: << without a delimiter\n");
-                // Handle error
-            }
-            i++;
-            continue;
-        }
-
         // Handle tokens that begin with a quote
         if ((split[i][0] == '"' || split[i][0] == '\'') &&
             split[i][strlen(split[i]) - 1] != split[i][0])
@@ -205,91 +187,6 @@ t_token *ft_tokenize(char *str)
     return token_list;  // Return the list of tokens (linked list)
 }
 
-
-t_token *ft_create_ast(t_token *token_list)
-{
-    t_token *root = NULL;
-    t_token *current = NULL;
-    t_token *new_node = NULL;
-	t_token *delimiter_node = NULL; // To store the delimiter token
-
-    while (token_list)
-    {
-        new_node = token_list;
-        token_list = token_list->right;
-        new_node->right = NULL;
-
-        if (!root)
-        {
-            root = new_node;//If there is no root. the first one become root. 
-        }
-        else
-        {
-			if (new_node->token == HEREDOC)
-            {
-				// The command before '<<' becomes the left child
-				new_node->left = current;
-				if (current)
-					current->parent = new_node;
-
-				// The delimiter is the next token
-				if (token_list)
-				{
-					delimiter_node = token_list;
-					token_list = token_list->right;
-					delimiter_node->right = NULL;
-					delimiter_node->left = NULL; // Ensure delimiter node has no children initially
-
-					new_node->left = root; // The current root (command) becomes left child
-					if (root)
-						root->parent = new_node;
-					new_node->right = delimiter_node; // Delimiter becomes right child
-					delimiter_node->parent = new_node;
-					root = new_node; // HEREDOC node becomes the new root
-					current = new_node;
-				}
-				else
-				{
-					fprintf(stderr, "Error: << without a delimiter in AST creation\n");
-					// Handle error appropriately
-				}
-
-				// The '<<' node becomes the new 'current' for subsequent operations
-				current = new_node;
-				continue; // Skip the default 'current' update at the end
-                
-            }
-            else if (new_node->precedence == 1 && current && current->precedence == 1)
-            {
-                // Join arguments (e.g., "echo hello world")
-                char *new_str = malloc(strlen(current->string) + strlen(new_node->string) + 2);
-                sprintf(new_str, "%s %s", current->string, new_node->string);
-                free(current->string);
-                current->string = new_str;
-                free(new_node);
-            }
-            else if (new_node->precedence > root->precedence)
-            {
-                new_node->left = root;
-                root->parent = new_node;
-                root = new_node;
-            }
-            else
-            {
-                current = root;
-                while (current->right)
-                    current = current->right;
-                current->right = new_node;
-                new_node->parent = current;
-            }
-        }
-        current = new_node;
-    }
-
-    return root; // Return the constructed AST
-}
-
-/* 3) work well. Before doing heredoc
 t_token *ft_create_ast(t_token *token_list)
 {
     t_token *root = NULL;
@@ -304,7 +201,7 @@ t_token *ft_create_ast(t_token *token_list)
 
         if (!root)
         {
-            root = new_node;//If there is no root. the first one become root. 
+            root = new_node;
         }
         else
         {
@@ -337,7 +234,6 @@ t_token *ft_create_ast(t_token *token_list)
 
     return root; // Return the constructed AST
 }
-*/
 
 t_token *ft_parse(char *str)
 {
@@ -352,6 +248,7 @@ t_token *ft_parse(char *str)
 /* 1) original codes from Cedric
 t_token **ft_tokenize(char *str)
 {
+    TEST_START;
     char    **split;
     int     token;
     int i;
@@ -367,11 +264,13 @@ t_token **ft_tokenize(char *str)
     i = 0;
     while (split[i])
     {
-        token = ft_get_token(split[i]); //get_token(*split);
+        token = ft_get_token(split[i]);
         ft_add_back_node(token_lst,  ft_new_token_node(split[i], token));
         i++;
     }
+    ft_display_token_sequence_lst(*token_lst);
     ft_split_clean(&split);
+    TEST_SUCCES;
     return(token_lst);
 }
 */
diff --git a/srcs/parser/tokenizer/tokenize.h b/srcs/parser/tokenizer/tokenize.h
index 35287ef..6f876e3 100644
--- a/srcs/parser/tokenizer/tokenize.h
+++ b/srcs/parser/tokenizer/tokenize.h
@@ -6,7 +6,7 @@
 /*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/25 11:52:00 by cw3l              #+#    #+#             */
-/*   Updated: 2025/03/26 09:39:14 by cbouhadr         ###   ########.fr       */
+/*   Updated: 2025/04/07 13:17:41 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -27,6 +27,18 @@
 
 #include "../../../include/main.h"
 
+#define WORD 0
+#define CMD 1
+#define ARG 3
+#define PIPE 4
+#define REDIR_OPEN 5
+#define REDIR_WRITE 6
+#define REDIR_WRITE_A 7
+#define DOUBLE_REDIR 8
+#define HEREDOC 10
+#define VAR 11
+#define BUILTIN 12
+
 typedef struct s_token
 {
     char            *string;
@@ -46,6 +58,7 @@ t_token *ft_new_token_node(char *str, int token);
 void    ft_add_back_node(t_token **lst, t_token *node);
 int     ft_is_commande(char *str);
 int     ft_get_token(char *str);
+int     ft_count_occurence_of_token(t_token *token_lst, int token);
 int     ft_delete_token_lst(t_token **token_lst);
 
 //display fonction
@@ -54,6 +67,9 @@ void    ft_display_token_node_lst(t_token *token_lst);
 void    ft_display_token_sequence_lst(t_token *token_lst);
 void	print_ast(t_token *node, int depth);
 void 	print_ast_simple(t_token *node, int indent);
+void   	ft_display_token_node(t_token *token_lst);
+
+
 
 
 int     ft_get_precedence(int token);
diff --git a/srcs/parser/tokenizer/tokenize_utils.c b/srcs/parser/tokenizer/tokenize_utils.c
index 4df74d2..35bfb13 100644
--- a/srcs/parser/tokenizer/tokenize_utils.c
+++ b/srcs/parser/tokenizer/tokenize_utils.c
@@ -3,25 +3,37 @@
 /*                                                        :::      ::::::::   */
 /*   tokenize_utils.c                                   :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/25 15:48:49 by cw3l              #+#    #+#             */
-/*   Updated: 2025/03/25 15:52:15 by cw3l             ###   ########.fr       */
+/*   Updated: 2025/04/03 16:15:49 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "tokenize.h"
 
-void    ft_display_token_node_lst(t_token *token_lst)
+void    ft_display_token_node(t_token *token_lst)
 {
+   if(token_lst)
+   {
+        printf("\nvoici la valeur du noeud: \n");
+        printf("string : %s\n", token_lst->string);
+        printf("Token : %s\n", ft_get_str_token(token_lst->token));
+        printf("Précedence : %d\n", token_lst->precedence);
+        printf("Associativité : %d\n", token_lst->asso);
+        token_lst = token_lst->right;
+        printf("\n");
+   } 
+}
+
 
-    while (token_lst->right)
+void    ft_display_token_node_lst(t_token *token_lst)
+{
+    if(!token_lst)
+        return ;
+    while (token_lst)
     {
-       printf("voici la valeur du noeud: \n");
-       printf("string : %s\n", token_lst->string);
-       printf("Token : %s\n", ft_get_str_token(token_lst->token));
-       printf("Précedence : %d\n", token_lst->precedence);
-       printf("Associativité : %d\n", token_lst->asso);
+       ft_display_token_node(token_lst);
        token_lst = token_lst->right;
        printf("\n");
     }
@@ -49,7 +61,7 @@ int ft_get_associativity(int token)
 void    ft_display_commande_lst(t_token *token_lst)
 {
 
-    while (token_lst->right)
+    while (token_lst)
     {
         if(token_lst->string)
             printf("%s ",token_lst->string);
@@ -80,6 +92,8 @@ char *ft_get_str_token(int token)
         return ("HEREDOC ");
     if (token == VAR)
         return ("VAR");
+    if (token == BUILTIN)
+        return ("BUILTIN");
     return(NULL);
 }
 
@@ -135,9 +149,31 @@ int ft_is_commande(char *str)
     ft_split_clean(&split);
     return(0);
 }
+
+int ft_is_builtin(char *str)
+{
+    if(ft_strncmp(str,"cd",ft_strlen("cd")) == 0)
+        return(1);
+    if(ft_strncmp(str,"echo",ft_strlen("echo")) == 0)
+        return(1);
+    if(ft_strncmp(str,"export",ft_strlen("export")) == 0)
+        return(1);
+    if(ft_strncmp(str,"env",ft_strlen("env")) == 0)
+        return(1);
+    if(ft_strncmp(str, "exit", ft_strlen("exit")) == 0)
+        return(1);
+    if(ft_strncmp(str, "pwd", ft_strlen("pwd")) == 0)
+        return(1);
+    if(ft_strncmp(str, "unset", ft_strlen("unset")) == 0)
+        return(1);
+    return(0);
+}
 int ft_get_token(char *str)
 {
-    if (ft_is_commande(str))
+    if(ft_is_builtin(str))
+        return(BUILTIN);
+    //&& nnot necessaire but...
+    if (ft_is_commande(str) && !ft_is_builtin(str))
         return (CMD);
     if (ft_strlen(str) == 1 && str[0] == '|')
         return (PIPE);
@@ -156,3 +192,29 @@ int ft_get_token(char *str)
     
     return (WORD);
 }
+
+void    ft_token_lst_iter(t_token *token, void (*f)(t_token *token_node, int token))
+{
+    if(!token || !f)
+        return ;
+    while(token)
+    {
+        f(token, token->token);
+        token = token->right;        
+    }
+}
+
+int ft_count_occurence_of_token(t_token *token_lst, int token)
+{
+    int i;
+
+    i = 0;
+    while (token_lst)
+    {
+        if (token_lst->token == token)
+            i++;
+        token_lst = token_lst->right;
+    }
+    return (i);
+    
+}
\ No newline at end of file
diff --git a/srcs/subsystems/subsystems.o b/srcs/subsystems/subsystems.o
deleted file mode 100644
index 3e7a531..0000000
Binary files a/srcs/subsystems/subsystems.o and /dev/null differ
diff --git a/test_unit/ast_test.c b/test_unit/ast_test.c
deleted file mode 100644
index 679c78a..0000000
--- a/test_unit/ast_test.c
+++ /dev/null
@@ -1,49 +0,0 @@
-/* ************************************************************************** */
-/*                                                                            */
-/*                                                        :::      ::::::::   */
-/*   ast_test.c                                         :+:      :+:    :+:   */
-/*                                                    +:+ +:+         +:+     */
-/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
-/*                                                +#+#+#+#+#+   +#+           */
-/*   Created: 2025/03/20 10:53:16 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/20 12:15:25 by cbouhadr         ###   ########.fr       */
-/*                                                                            */
-/* ************************************************************************** */
-
-#include "test_unit.h"
-
-int tst_ast(void)
-{
-
-    TEST_START;
-    t_ast_node *new_node_1;
-    t_ast_node *new_node_2;
-    t_ast_node *new_node_3;
-    t_ast_node *new_node_4;
-    t_ast_node *new_node_5;
-    t_ast_node *new_node_6;
-    t_ast_node *new_node_7;
-
-
-    new_node_1 = ft_new_ast_node("Node", 124);
-    new_node_2 = ft_new_ast_node("Node", 60);
-    new_node_3 = ft_new_ast_node("Node", 62);
-    new_node_4 = ft_new_ast_node("Node", 65);
-    new_node_5 = ft_new_ast_node("Node", 66);
-    new_node_6 = ft_new_ast_node("Node", 67);
-    new_node_7 = ft_new_ast_node("Node", 68);
-
-    new_node_1->left= new_node_2;
-    new_node_1->right = new_node_3;
-    new_node_2->left = new_node_4;
-    new_node_2->right = new_node_5;
-    new_node_3->left = new_node_6;
-    new_node_3->right = new_node_7;
-
-    ft_ast_iter(new_node_1, ft_print_ast_value);
-
-    DEBUGG;
-
-    TEST_SUCCES;
-    return(1);
-}
\ No newline at end of file
diff --git a/test_unit/test_unit.h b/test_unit/test_unit.h
index bbee8be..881cb61 100644
--- a/test_unit/test_unit.h
+++ b/test_unit/test_unit.h
@@ -3,10 +3,10 @@
 /*                                                        :::      ::::::::   */
 /*   test_unit.h                                        :+:      :+:    :+:   */
 /*                                                    +:+ +:+         +:+     */
-/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*   By: cw3l <cw3l@student.42.fr>                  +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/17 13:17:20 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/26 09:25:03 by cbouhadr         ###   ########.fr       */
+/*   Updated: 2025/04/02 18:53:00 by cw3l             ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -14,8 +14,9 @@
 #define TEST_UNIT_H
 
 #include "../srcs/parser/parser.h"
+#include "../srcs/execution/execution.h"
+#include "../srcs/builtin/builtin.h"
 #include "../srcs/parser/lexer/precedence_climbing.h"
-#include "../srcs/parser/lexer/ast_parser/ast.h"
 #include "../include/main.h"
 #include <assert.h>
 
@@ -23,6 +24,9 @@
 int tst_ast(void);
 int tst_shutting(void);
 int tst_tokenizer(void);
-
+int tst_builtin(int argc, char *envp[]);
+int tst_exe(void);
+int tst_export(char *envp[]);
+int tst_quick(int argc, char **argv, char *envp[]);
 
 #endif
\ No newline at end of file
diff --git a/test_unit/tst_builtin.c b/test_unit/tst_builtin.c
new file mode 100644
index 0000000..35129ff
--- /dev/null
+++ b/test_unit/tst_builtin.c
@@ -0,0 +1,111 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   tst_builtin.c                                      :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 10:52:29 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/07 12:06:49 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "test_unit.h"
+
+int ft_read_line_test(char *str)
+{
+    char *line;
+    //t_token **token_lst;
+    
+    while (1)
+    {
+        line = readline(str);
+        if(!line)
+            return(1);
+        // token_lst = ft_tokenize(line);
+        // ft_display_token_node_lst(*token_lst);
+        printf("voici line %s\n", line);
+        ft_cd(line);
+        ft_pwd();
+    }
+    return(0);
+}
+
+int ft_start_minishell_test(char *str)
+{
+    int read;
+
+    read = ft_read_line_test(str);
+    if(read == 1)
+        return(1);
+    return(0);
+}
+// cd ok
+// pwd ok
+// echo ok
+//export
+//unset
+//exit
+
+int ft_print_envirion(char **str)
+{
+    int i;
+
+    i = 0;
+    while (*str)
+    {
+        printf("%s\n",*str);
+        str++;
+        i++;
+    }
+    printf("\n");
+    return(i);
+}
+
+void    ft_prin(void)
+{
+    printf("Exit\n");
+}
+
+void    ft_filter_token(t_token *token_node, int token_value)
+{
+    if(!token_node)
+        return ;
+    if(token_node->token == token_value)
+    {
+        ft_display_token_node(token_node);
+    }
+}
+
+int tst_builtin(int argc, char *envp[])
+{
+    char *line;
+    t_token *token_lst;
+    char **duplicate_env;
+    (void)argc;
+    
+
+
+    //build quick sort algo
+    duplicate_env = ft_duplicate_env(envp);
+    ft_set_signal();
+    while (1)
+    {
+        line = readline("minni ");
+        if(!line)
+            exit(0);
+        token_lst = ft_tokenize(line);
+        if(!token_lst)
+            return(-1);
+        if(ft_strncmp(line, "print",5) == 0)
+            ft_display_token_node_lst(token_lst);
+        else
+        {
+            //ft_cmd_launcher(*token_lst);
+            ft_export(&duplicate_env, NULL);
+        }
+
+    }
+    
+    return(1);
+}
\ No newline at end of file
diff --git a/test_unit/tst_exe.c b/test_unit/tst_exe.c
new file mode 100644
index 0000000..7d0ab73
--- /dev/null
+++ b/test_unit/tst_exe.c
@@ -0,0 +1,21 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   tst_exe.c                                          :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 10:52:29 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/03/28 16:17:12 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "test_unit.h"
+
+int tst_exe(void)
+{
+
+    // char *arg[] = {"echo", "salut la compagnie", NULL};
+    // ft_cmd_launcher("/usr/bin/echo",arg);
+    return(1);
+}
\ No newline at end of file
diff --git a/test_unit/tst_export.c b/test_unit/tst_export.c
new file mode 100644
index 0000000..3dbba96
--- /dev/null
+++ b/test_unit/tst_export.c
@@ -0,0 +1,174 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   tst_export.c                                       :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/03/26 10:52:29 by cbouhadr          #+#    #+#             */
+/*   Updated: 2025/04/04 15:05:02 by cbouhadr         ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
+#include "test_unit.h"
+
+/* 
+    Error msg:  export 1hello = export: not an identifier: 1hello
+                export hello# = export: not valid in this context: hello#
+                export hello* = zsh: no matches found: hello*
+                export =d     = zsh: d not found
+                export a==1   = zsh: 1 not found
+
+*/
+
+
+
+
+
+int ft_tst_check_variable(void)
+{
+    TEST_START;
+     // valide arg:
+    char *var_test_1 = "H=0000";
+    char *var_test_2 = "H00000";
+    char *var_test_3 = "H=hello";
+    char *var_test_4 = "HelloWorld";
+
+    // In valide args
+
+    char *invar_test_1 = "100H";
+    char *invar_test_2 = "H=hello*";
+    char *invar_test_3 = "H=hello*";
+    char *invar_test_4 = "1hello";
+    char *invar_test_5 = "hello#";
+    char *invar_test_6 = "hello*";
+    
+
+    assert(ft_check_variable(var_test_1) == 1);
+    assert(ft_check_variable(var_test_2) == 1);
+    assert(ft_check_variable(var_test_3) == 1);
+    assert(ft_check_variable(var_test_4) == 1);
+
+    assert(ft_check_variable(invar_test_1) == 0);
+    assert(ft_check_variable(invar_test_2) == 0);
+    assert(ft_check_variable(invar_test_3) == 0);
+    assert(ft_check_variable(invar_test_4) == 0);
+    assert(ft_check_variable(invar_test_5) == 0);
+    assert(ft_check_variable(invar_test_6) == 0);
+    TEST_SUCCES;
+    return(1);
+}
+
+int ft_tst_count_variable(void)
+{
+    TEST_START;
+    
+    char *str[] = {"H=0000", "H00000", "H=hello", "H=hello*", NULL};
+    assert(ft_count_valide_variable(str) == 3);
+    assert(ft_count_valide_variable(NULL) == 0);
+
+    char *str2[] = {"100H", "H=hello*", "H=hello", "H=hello*", NULL};
+    assert(ft_count_valide_variable(str2) == 1);
+    
+    char *str3[] = {"100H", "H=hello*", "1hello", "H=hello#", NULL};
+    assert(ft_count_valide_variable(str3) == 0);
+    
+    char *str4[] = {"E=0000", "HelloWorld", "F=hello", "G=world", NULL};
+    assert(ft_count_valide_variable(str4) == 4);
+    
+    char *str5[] = {"E=00s00", NULL, "F=hello", "G=world", NULL};
+    assert(ft_count_valide_variable(str5) == 1);
+    
+    TEST_SUCCES;
+    return (1);
+}
+
+int  ft_tst_add_var(void)
+{
+    TEST_START;
+    char *str = "hello world comment ca va ?";
+    char *str2 = "bien merci je t'en prie";
+    char **env = ft_split(str, 32);
+    char **add = ft_split(str2, 32);
+    
+    char **new = ft_add_variable(env, add);
+    free(env);
+    free(add);
+    
+    ft_split_clean(&new);
+    (void)new;
+    TEST_SUCCES;
+    return(1);    
+}
+
+int tst_export(char *envp[])
+{
+    // REVOIR LA FONCTION DE TRIE DE L'ENV
+    TEST_START;
+    (void)envp;
+
+    // char *ss = ft_strdup("hello=world");
+    
+    // char *s = ft_extract_var(ss);
+    
+    // printf("voici %s\n",s);
+
+    
+    assert(ft_tst_check_variable() == 1);
+    assert(ft_tst_count_variable() == 1);
+    assert(ft_tst_add_var() == 1);
+    
+    char **d = ft_duplicate_env(envp);
+    env_quick_s(d,ft_get_split_len(envp),ft_str_env_cmp);
+    ft_display_env(d);
+
+    // char **e = ft_duplicate_env(envp);
+    // char *env = "Z1=0 Z2=1 Z3=22";
+    // char **split = ft_split(env,32);
+
+    // assert(ft_is_split_sort(e));
+    
+    //int actual_len = ft_get_split_len(e);
+
+    //ft_export(&e, &split);
+
+    // int new_len = ft_get_split_len(e);
+
+    // char *d = "Z22=101 Z2=101 ";
+    // char **pli = ft_split(d,32);
+    
+    // actual_len = ft_get_split_len(e);
+    
+    // PRINT_INT(actual_len);
+    // ft_export(&e, &pli);
+
+    // new_len = ft_get_split_len(e);
+    
+    // PRINT_INT(new_len);
+    // assert(new_len == actual_len + 1);
+
+    
+    // //test for dupplicate variable.
+    // char *p = "Z=0 Z=1 Z=2";
+    // char **plit = ft_split(p, 32);
+    
+    // actual_len = ft_get_split_len(e);
+    
+    // ft_export(&e, &plit);
+    
+    // new_len = ft_get_split_len(e);
+    
+    // assert(ft_is_env_sort(e));
+
+    // printf("voici la  len %d and %d\n", new_len, actual_len);
+    // assert(ft_is_env_sort(e) && new_len == actual_len + 1);
+
+
+    // char *ps = "Z33=2333 Z78=0";
+    // char **lit = ft_split(ps, 32);
+    // ft_export(&e, &lit);
+    
+    //ft_split_clean(&e);
+    TEST_SUCCES;
+    return(1);
+}
\ No newline at end of file
diff --git a/test_unit/tst_main.c b/test_unit/tst_main.c
index e872c4b..77d0897 100644
--- a/test_unit/tst_main.c
+++ b/test_unit/tst_main.c
@@ -6,18 +6,33 @@
 /*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/17 13:17:01 by cbouhadr          #+#    #+#             */
-/*   Updated: 2025/03/26 09:28:57 by cbouhadr         ###   ########.fr       */
+/*   Updated: 2025/04/04 15:53:56 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
 #include "test_unit.h"
 
 
-int main(void)
+int main(int argc, char **argv, char *envp[])
 {
+    TEST_START;
+    (void)argv;
+    (void)argc;
+    (void)envp;
 
-    assert(tst_tokenizer() == 1);
-    
+    //ft_sort_env(envp);
+    //ft_split_quick_sort(envp, ft_get_split_len(envp),ft_strncmp);
+    // ft_split_print(envp);
+    //assert(tst_quick(argc, argv,envp) == 1);
+    // assert(ft_is_split_sort(envp));
+
+    //tst_quick(argc, argv,envp);
+    // assert(tst_tokenizer() == 1);
+    assert(tst_export(envp) == 1);
 
+    //printf("%d\n",tst_builtin(argc,envp));
+    //assert(tst_exe() == 1);
+    
+    TEST_SUCCES;
     return(0);
 }
\ No newline at end of file
diff --git a/test_unit/tst_tokenizer.c b/test_unit/tst_tokenizer.c
index e71366f..2ddedf0 100644
--- a/test_unit/tst_tokenizer.c
+++ b/test_unit/tst_tokenizer.c
@@ -6,7 +6,7 @@
 /*   By: cbouhadr <cbouhadr@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2025/03/25 12:07:18 by cw3l              #+#    #+#             */
-/*   Updated: 2025/03/26 09:29:32 by cbouhadr         ###   ########.fr       */
+/*   Updated: 2025/04/07 12:07:47 by cbouhadr         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
@@ -32,7 +32,8 @@ int tst_commande_checker(void)
 
 int tst_get_token(void)
 {
-    assert(ft_get_token("echo") == CMD);
+    TEST_START;
+    assert(ft_get_token("echo") == BUILTIN);
     assert(ft_get_token("cat") == CMD);
     assert(ft_get_token("<<") == HEREDOC);
     assert(ft_get_token(">>") == REDIR_WRITE_A);
@@ -42,27 +43,33 @@ int tst_get_token(void)
     assert(ft_get_token("$hello") == VAR);
     assert(ft_get_token("$hello") == VAR);
     assert(ft_get_token("hello") == WORD);
-    
+    assert(ft_get_token("pwd") == BUILTIN);
+    assert(ft_get_token("cd") == BUILTIN);
+    assert(ft_get_token("exit") == BUILTIN);
+    assert(ft_get_token("export") == BUILTIN);
+    assert(ft_get_token("env") == BUILTIN);
+    assert(ft_get_token("unset") == BUILTIN);
+
+    TEST_SUCCES;
     return(1);
 }
 
 
 int tst_tokenizer(void)
 {
-    t_token **token_lst;
+    t_token *token_lst;
     
-    char line[] = "Hello grep -m | cat > output.txt"; 
+    char line[] = "echo < hello.txt | grep 'Hello world'"; 
 
     
     tst_commande_checker();
     tst_get_token();
     
     token_lst = ft_tokenize(line);
-
-    ft_display_token_node_lst(*token_lst);
-    ft_display_commande_lst(*token_lst);
-    ft_display_token_sequence_lst(*token_lst);
-    ft_delete_token_lst(token_lst);
+    ft_display_token_node_lst(token_lst);
+    ft_display_commande_lst(token_lst);
+    ft_display_token_sequence_lst(token_lst);
+    ft_delete_token_lst(&token_lst);
     
     return(1);
 }
\ No newline at end of file
